<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Nodejs RESTFul架构实践 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="准备如果你不了解http协议，先看一下https://github.com/i5ting/node-http
什么是REST？RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。
以下内容摘自阮一峰的文章：
一、起源
REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。
二、名称
Fi">
<meta property="og:type" content="article">
<meta property="og:title" content="Nodejs RESTFul架构实践">
<meta property="og:url" content="http://yoursite.com/2015/06/09/expressjs-rest/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="准备如果你不了解http协议，先看一下https://github.com/i5ting/node-http
什么是REST？RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。
以下内容摘自阮一峰的文章：
一、起源
REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。
二、名称
Fi">
<meta property="og:image" content="http://yoursite.com/img/2015-06-09/1.png">
<meta property="og:image" content="http://yoursite.com/img/node全栈-公众号.png">
<meta property="og:updated_time" content="2015-08-07T06:07:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nodejs RESTFul架构实践">
<meta name="twitter:description" content="准备如果你不了解http协议，先看一下https://github.com/i5ting/node-http
什么是REST？RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。
以下内容摘自阮一峰的文章：
一、起源
REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。
二、名称
Fi">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-expressjs-rest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/09/expressjs-rest/" class="article-date">
  <time datetime="2015-06-08T16:00:00.000Z" itemprop="datePublished">2015-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Nodejs RESTFul架构实践
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="准备">准备</h2><p>如果你不了解http协议，先看一下<a href="https://github.com/i5ting/node-http" target="_blank" rel="external">https://github.com/i5ting/node-http</a></p>
<h2 id="什么是REST？">什么是REST？</h2><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>以下内容摘自阮一峰的文章：</p>
<p>一、起源</p>
<p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p>
<p>二、名称</p>
<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。<br>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>三、资源（Resources）</p>
<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>四、表现层（Representation）</p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>五、状态转化（State Transfer）</p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>六、综述</p>
<p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p><strong>说的通俗一点，改变url写法，让它带有状态，即语义化</strong></p>
<p>更多详见：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li>
<li><a href="http://www.restapitutorial.com/lessons/whatisrest.html" target="_blank" rel="external">http://www.restapitutorial.com/lessons/whatisrest.html</a></li>
</ul>
<h2 id="请求方法">请求方法</h2><p>一般会严格要求请求方法及其释义，下面给出常用的请求方法</p>
<ul>
<li>如果请求头中存在 <code>X-HTTP-Method-Override</code> 或参数中存在 <code>_method</code>（拥有更高权重），且值为 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>, <code>OPTION</code>, <code>HEAD</code> 之一，则视作相应的请求方式进行处理</li>
<li><code>GET</code>, <code>DELETE</code>, <code>HEAD</code> 方法，参数风格为标准的 <code>GET</code> 风格的参数，如 <code>url?a=1&amp;b=2</code></li>
<li><code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>OPTION</code> 方法<ul>
<li>默认情况下请求实体会被视作标准 json 字符串进行处理，当然，依旧推荐设置头信息的 <code>Content-Type</code> 为 <code>application/json</code></li>
<li>在一些特殊接口中（会在文档中说明），可能允许 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 或者 <code>multipart/form-data</code> ，此时请求实体会被视作标准 <code>POST</code> 风格的参数进行处理</li>
</ul>
</li>
</ul>
<p>关于方法语义的说明：</p>
<ul>
<li><code>OPTIONS</code> 用于获取资源支持的所有 HTTP 方法</li>
<li><code>HEAD</code> 用于只获取请求某个资源返回的头信息</li>
<li><code>GET</code> 用于从服务器获取某个资源的信息<ul>
<li>完成请求后返回状态码 <code>200 OK</code></li>
<li>完成请求后需要返回被请求的资源详细信息</li>
</ul>
</li>
<li><code>POST</code> 用于创建新资源<ul>
<li>创建完成后返回状态码 <code>201 Created</code></li>
<li>完成请求后需要返回被创建的资源详细信息</li>
</ul>
</li>
<li><code>PUT</code> 用于完整的替换资源或者创建指定身份的资源，比如创建 id 为 123 的某个资源<ul>
<li>如果是创建了资源，则返回 <code>201 Created</code></li>
<li>如果是替换了资源，则返回 <code>200 OK</code></li>
<li>完成请求后需要返回被修改的资源详细信息</li>
</ul>
</li>
<li><code>PATCH</code> 用于局部更新资源<ul>
<li>完成请求后返回状态码 <code>200 OK</code></li>
<li>完成请求后需要返回被修改的资源详细信息</li>
</ul>
</li>
<li><code>DELETE</code> 用于删除某个资源<ul>
<li>完成请求后返回状态码 <code>204 No Content</code></li>
</ul>
</li>
</ul>
<p>上面是比较常见的，估计大部分人最常用的是2个，get和post，具体每个怎么玩，下面会给出实例</p>
<h2 id="最常见的增删改查">最常见的增删改查</h2><p>以前大家都认为管理信息系统就是crud，认为没有啥技术含量，哎，真正能把crud写明白其实也不是一件容易的事儿</p>
<p>七个路由，见<code>app/routes/users.js</code></p>
<p>其中4个路由是crud</p>
<ul>
<li>GET    /users[/]        =&gt; user.list()</li>
<li>POST   /users[/]        =&gt; user.create()</li>
<li>PATCH  /users/:id       =&gt; user.update()</li>
<li>DELETE /users/:id       =&gt; user.destroy()</li>
</ul>
<p>另外3个是页面渲染用的</p>
<ul>
<li>GET    /users/new       =&gt; user.new()</li>
<li>GET    /users/:id       =&gt; user.show()</li>
<li>GET    /users/:id/edit  =&gt; user.edit()</li>
</ul>
<p>那么我们先来看一下crud对应的请求方法</p>
<ul>
<li>get用于请求列表</li>
<li>post用于创建</li>
<li>patch用于更新，局部更新资源</li>
<li>delete用于删除</li>
</ul>
<p>对比上一节的内容，你会发现他们的含义貌似真的对了，唯一可能有争议是更新，有的人用put有的用patch，推荐patch</p>
<p>以前做java的时候会认为，创建、删除和更新都用post，查询和搜索用get，这样做没问题，只是不符合rest风格而已。</p>
<p>很多人和我讨论过到该不该rest，我的回答是</p>
<ul>
<li><a href="https://cnodejs.org/topic/552b3b9382388cec50cf6d95" target="_blank" rel="external">客户端 API 开发总结</a></li>
</ul>
<h2 id="express代码分层">express代码分层</h2><p>默认的express生成器生成的只有routes和views文件夹，相对比较简单，做大型应用怎么能少了mvc呢？</p>
<p>于是我仿照rails写了如下代码分层</p>
<ul>
<li>routes 路由层，只有url和中间件，不包含任何逻辑</li>
<li>controllers 业务逻辑控制层</li>
<li>models  模型层</li>
<li>views  视图层</li>
</ul>
<p>如下图</p>
<p><img src="/img/2015-06-09/1.png" alt=""></p>
<h2 id="路由层">路由层</h2><p>上代码</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> router = express.Router();

<span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'../controllers/users_controller'</span>);


<span class="comment">// -- custom</span>


<span class="comment">/**
 * Auto generate RESTful url routes.
 *
 * URL routes:
 *
 *  GET    /users[/]        =&gt; user.list()
 *  GET    /users/new       =&gt; user.new()
 *  GET    /users/:id       =&gt; user.show()
 *  GET    /users/:id/edit  =&gt; user.edit()
 *  POST   /users[/]        =&gt; user.create()
 *  PATCH  /users/:id       =&gt; user.update()
 *  DELETE /users/:id       =&gt; user.destroy()
 *
 */</span>

router.get(<span class="string">'/new'</span>, $.<span class="keyword">new</span>);  
router.get(<span class="string">'/:id/edit'</span>, $.edit);

router.route(<span class="string">'/'</span>)
  .get($.list)
  .post($.create);

router.route(<span class="string">'/:id'</span>)
  .patch($.update)
  .get($.show)
  .delete($.destroy);


<span class="built_in">module</span>.exports = router;
</code></pre><p>和普通的路由代码一样，稍微改造了一下，统一了地址，应该是更清晰了。</p>
<p>这里只是引入了<code>users_controller</code>文件，完成请求地址和业务处理代码的映射而已。</p>
<p>这里还要讨论一个问题，每次增加一个接口就要加一个路由会比较烦，而且要在app.js里配置，能不能自动加载呢？比如app/routes目录下的所有js都可以挂载到app上</p>
<p>答案是可以的，使用我写的<code>mount-routes</code>即可，示例如下：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)
<span class="keyword">var</span> app = express()

<span class="keyword">var</span> mount = <span class="built_in">require</span>(<span class="string">'mount-routes'</span>);

<span class="comment">// 简单用法，加载app/routes下的所有路由</span>
<span class="comment">// mount(app);</span>

<span class="comment">// 带路径的用法，加载routes2目录下的所有路由</span>
<span class="comment">// mount(app, 'routes2');</span>

<span class="comment">// 带路径的用法并且可以打印出路有表</span>
mount(app, <span class="string">'routes2'</span>, <span class="literal">true</span>);

<span class="comment">// start server</span>
app.listen(<span class="number">23018</span>)
</code></pre><p>更多内容见</p>
<p><a href="https://cnodejs.org/topic/556bd8ecf6ec9c0f020377c2" target="_blank" rel="external">mount-routes</a></p>
<h2 id="控制层">控制层</h2><pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Created by sang on 01/06/14.
 <span class="keyword">*</span>/

var User = require('../models/user');
</code></pre><p>首先，控制层是控制业务处理的，所以它和模型层打交道比较多，同时控制视图如何展示</p>
<pre><code>exports.list = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users =&gt; list, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query));
  User.getAll(<span class="function"><span class="keyword">function</span>(<span class="params">err, users</span>)</span>{
    <span class="built_in">console</span>.log(users);
    res.render(<span class="string">'users/index'</span>, {
      users : users
    })
  });
};
</code></pre><p>请求所有列表，很简单，获取所有用户即可</p>
<pre><code>exports.new = function (req, res, next) {
  console.log(req.<span class="keyword">method</span> + ' /users/new =&gt; new, query: ' + <span class="type">JSON</span>.stringify(req.query));

  res.render('users/new', {
    user : {
      <span class="string">"_action"</span> : <span class="string">"new"</span>
    }
  })
};
</code></pre><p>新建用户，实际是render视图而已，没有啥逻辑，user参数是为了我生成代码方便用的，无他</p>
<pre><code>exports.show = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id =&gt; show, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params));
  <span class="keyword">var</span> id = req.params.id;

  User.getById(id, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
    <span class="built_in">console</span>.log(user);
    res.render(<span class="string">'users/show'</span>, {
      user : user
    })
  });
};
</code></pre><p>同new，是render视图代码</p>
<pre><code>exports.edit = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id/edit =&gt; edit, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params));

  <span class="keyword">var</span> id = req.params.id; 

  User.getById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
    <span class="built_in">console</span>.log(user);
    user._action = <span class="string">'edit'</span>;

    res.render(<span class="string">'users/edit'</span>, {
      user : user
    })
  });
};
</code></pre><p>同new，是render视图代码</p>
<pre><code>exports.create = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users =&gt; create, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params) + <span class="string">', body: '</span> + <span class="built_in">JSON</span>.stringify(req.body));

    User.create({name: req.body.name,password: req.body.password}, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="built_in">console</span>.log(user);
      res.render(<span class="string">'users/show'</span>, {
        user : user
      })
    });
};
</code></pre><p>这段是创建用户的代码，根据post参数，保存入库，跳转到展示详情页面</p>
<pre><code>exports.update = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id =&gt; update, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params) + <span class="string">', body: '</span> + <span class="built_in">JSON</span>.stringify(req.body));

    <span class="keyword">var</span> id = req.params.id; 

    User.updateById(id,{name: req.body.name,password: req.body.password}, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="built_in">console</span>.log(user);

      res.json({
        data:{
          redirect : <span class="string">'/users/'</span> + id
        },
        status:{
          code : <span class="number">0</span>,
          msg  : <span class="string">'delete success!'</span>
        }
      });
    });
};
</code></pre><p>和创建类似，它是根据id来更新内容</p>
<pre><code>exports.destroy = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id =&gt; destroy, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params) + <span class="string">', body: '</span> + <span class="built_in">JSON</span>.stringify(req.body));

  <span class="keyword">var</span> id = req.params.id;
  User.deleteById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(err);
    res.json({
      data:{},
      status:{
        code : <span class="number">0</span>,
        msg  : <span class="string">'delete success!'</span>
      }
    });
  });
};
</code></pre><p>和创建类似，它是根据id来删除内容</p>
<p>以上代码形式都是一样的</p>
<pre><code>exports.xxxx = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span> </span>{
  ...
}
</code></pre><p>他实际上connect中间件的标准写法，如果你熟悉express，可以非常简单的上手，看了这些代码，你一定很好奇，User模型是怎么工作的，而且mongoose里并没有这些方法啊，下面会详细说明</p>
<h2 id="模型层">模型层</h2><p>我们的模型层使用的是比较传统的mongoose，如果需要promise库，可以搭配bluebird</p>
<pre><code><span class="comment">/**
 * Created by alfred on 01/06/14.
 */</span>

<span class="keyword">var</span> mongoose    = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);
<span class="keyword">var</span> Schema      = mongoose.Schema;
<span class="keyword">var</span> MongooseDao = <span class="built_in">require</span>(<span class="string">'mongoosedao'</span>);

<span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(
    {<span class="string">"name"</span>:<span class="string">"String"</span>,<span class="string">"password"</span>:<span class="string">"String"</span>}
);

<span class="keyword">var</span> User = mongoose.model(<span class="string">'User'</span>, userSchema);
<span class="keyword">var</span> UserDao = <span class="keyword">new</span> MongooseDao(User);

<span class="built_in">module</span>.exports = UserDao;
</code></pre><p>这实际是最简单的定义mongoose模型的方法，我们唯一做的改进是增加了MongooseDao</p>
<p>DAO是java的概念，是data access object，即数据访问对象，就是传说的crud方法</p>
<p>你只要知道模型就好，为啥每个crud都要写呢？那得多烦啊</p>
<pre><code><span class="keyword">var</span> UserDao = <span class="keyword">new</span> MongooseDao(User);
</code></pre><p>这样就可以给user增加了基本的crud方法</p>
<p>所以在controller里我们看到了如下代码</p>
<ul>
<li>User.getAll(function(err, users){</li>
<li>User.getById(id, function(err, user) {</li>
<li>User.create({name: req.body.name,password: req.body.password}, function (err, user) {</li>
<li>User.updateById(id,{name: req.body.name,password: req.body.password}, function (err, user) {</li>
<li>User.deleteById(id, function (err) {</li>
</ul>
<p>这5个方法，完美的完成crud的所有操作，是不是很爽？至少少写了很多代码</p>
<p>而且当你想扩展的时候，你可以使用<code>User.model</code>来操作mongoose对象</p>
<p>比如login，我需要在User模型增加is_exist方法</p>
<pre><code><span class="keyword">var</span> mongoose    = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);
<span class="keyword">var</span> Schema      = mongoose.Schema;
<span class="keyword">var</span> MongooseDao = <span class="built_in">require</span>(<span class="string">'mongoosedao'</span>);

<span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(
    {<span class="string">"name"</span>:<span class="string">"String"</span>,<span class="string">"password"</span>:<span class="string">"String"</span>}
);

userSchema.methods.is_exist = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>{
  <span class="keyword">var</span> query;
  query = {
    username: <span class="keyword">this</span>.username,
    password: <span class="keyword">this</span>.password
  };
  <span class="keyword">return</span> <span class="keyword">this</span>.model(<span class="string">'User'</span>).findOne(query, cb);
};

<span class="keyword">var</span> User = mongoose.model(<span class="string">'User'</span>, userSchema);
<span class="keyword">var</span> UserDao = <span class="keyword">new</span> MongooseDao(User);

<span class="built_in">module</span>.exports = UserDao;
</code></pre><p>这就是mongoose里的实例方法，static方法也是一样，你可以玩各种花样</p>
<p>然后控制层</p>
<pre><code>exports.login = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span> </span>{
  username = req.body.username;
  password = req.body.password;

  user = <span class="keyword">new</span> User.model({
    username: username,
    password: password
  });

  <span class="keyword">return</span> user.is_exist(<span class="function"><span class="keyword">function</span><span class="params">(err, usr)</span> </span>{
     。。。
  });
}
</code></pre><p>是不是很简单？</p>
<h2 id="视图层">视图层</h2><p>视图层我们采用express默认的jade，无论各位怎么看，jade都可圈可点</p>
<p>1）extends 方式使用布局<br>2）include 复用模型代码<br>3）block 复用块代码</p>
<p>以new.jade和edit.jade为例，它们具有代表性</p>
<p>new.jade</p>
<pre><code>extends ../layouts/layout

block <span class="attribute">content</span>
  <span class="tag">h1</span> New user

  include user

  <span class="function"><span class="title">a</span><span class="params">(href=<span class="string">'/users'</span>)</span></span> Back
</code></pre><p>edit.jade</p>
<pre><code><span class="keyword">extends</span> ..<span class="regexp">/layouts/</span>layout

block content
  h1 Editing user

  <span class="keyword">include</span> user

  a(href=<span class="string">'/users/#{ user._id}'</span>) Show
  span |
  a(href=<span class="string">'/users'</span>) Back
</code></pre><p>首先要说明的是include用法，include类似于partial概念，可以包含一个jade作为一部分</p>
<p>jade里有一个约定，你include了谁，它就要把这个对象传进去</p>
<p>所以user.jade里才是我们复用的重点</p>
<pre><code>-<span class="ruby"> var _action = user._action == <span class="string">'edit'</span> ? <span class="string">'#'</span> <span class="symbol">:</span> <span class="string">'/users/'</span>
</span>-<span class="ruby"> var _method = user._action == <span class="string">'edit'</span> ? <span class="string">""</span>  <span class="symbol">:</span> <span class="string">"post"</span>
</span>-<span class="ruby"> var _type   = user._action == <span class="string">'edit'</span> ? <span class="string">"button"</span>  <span class="symbol">:</span> <span class="string">"submit"</span>
</span>-<span class="ruby"> var onClick  = user._action == <span class="string">'edit'</span> ?  <span class="string">"click_edit('user-"</span> + user._action + <span class="string">"-form','/users/"</span> + user._id + <span class="string">"/')"</span> <span class="symbol">:</span> <span class="string">""</span>
</span>form(id='user-#{<span class="ruby"> user._action}</span>-form',action="#{<span class="ruby">_action}</span>", method="#{<span class="ruby">_method}</span>",role='form')
  each n in ['user.name','user.password']
    -<span class="ruby"> m = eval(n);
</span>    div(class="field")
      label #{<span class="ruby">n.split(<span class="string">'.'</span>)[<span class="number">1</span>]}</span> #{<span class="ruby">m}</span>
      br
      input(type='text',name="#{<span class="ruby">n.split(<span class="string">'.'</span>)[<span class="number">1</span>]}</span>" ,value="#{<span class="ruby"> m == undefined ? <span class="string">''</span> <span class="symbol">:</span> m }</span>")

  div(class="actions") 
    input(type='#{<span class="ruby">_type}</span>',value='Submit',onClick='#{<span class="ruby">onClick}</span>')
</code></pre><p>这段是为了复用写的代码，可读性不强，但可以说明include用法，对于代码而言，达到了一定的复用</p>
<p>实际上我们自己jade的适合要尽可能的拆分成小块去复用，当需求变得时候更容易应变。提醒强迫症患者，当心物极必反，不要刻意去强求</p>
<h2 id="总结一下">总结一下</h2><p>RESTful架构大势所趋，代码写的标准了让人觉得赞</p>
<p>Expressjs下可以写的很规范，可以有做大应用，可以有很好的分层</p>
<p>展示了MVC + Routes的标准rest写法</p>
<p>使用了几个开源代码</p>
<ul>
<li>mount-routes</li>
<li>MongooseDao</li>
</ul>
<p>完成了以上工作，我们还要继续反思一下，既然rest是标准，写法很固定，是不是可以量产呢？答案是可以的，我展示的所有代码是根据一条命令搞定的</p>
<pre><code>moag user <span class="property">name</span>:<span class="type">string</span> password:<span class="type">string</span>
</code></pre><p>这就是我目前在写的一个开源项目，待可用的时候会公开的，敬请期待</p>
<p>延伸阅读</p>
<ul>
<li>Nodejs RESTFul架构实践之api篇 <a href="http://nodeonly.com/2015/06/14/node-restful-api.html" target="_blank" rel="external">http://nodeonly.com/2015/06/14/node-restful-api.html</a></li>
</ul>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/09/expressjs-rest/" data-id="cid18nwhy000jmt7fcp0htf6f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/06/10/expressjs-rest/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          监控Nodejs的页面响应时间
        
      </div>
    </a>
  
  
    <a href="/2015/06/05/node-excel-practice/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Nodejs 里Excel开发实践</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/jekyll-update/">jekyll update</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-update/">node update</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/08/07/mongoose-cli/">mongoose-cli</a>
          </li>
        
          <li>
            <a href="/2015/07/12/to-us/">良苦用心几人懂</a>
          </li>
        
          <li>
            <a href="/2015/07/07/gulp-in-action/">gulp结构化</a>
          </li>
        
          <li>
            <a href="/2015/07/07/npm-postinstall/">从npm tips到express插件机制设计</a>
          </li>
        
          <li>
            <a href="/2015/07/04/mongo-paging/">mongodb分页优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>