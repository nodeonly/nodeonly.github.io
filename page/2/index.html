<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/25/test/" class="article-date">
  <time datetime="2015-06-24T16:00:00.000Z" itemprop="datePublished">2015-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/25/test/">TAP &amp; Tape, the awesome way to test JavaScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>TAP &amp; Tape, the awesome way to test JavaScript</p>
<p><a href="http://www.macwright.org/2014/03/11/tape-is-cool.html" target="_blank" rel="external">原文</a>,如果有时间可以翻译一下，很不错的一篇介绍node测试相关的文章</p>
<p><img src="/css/2015-06-25/1.jpg" alt=""></p>
<p><a href="https://github.com/isaacs/node-tap" target="_blank" rel="external">node-tap</a> &amp; <a href="https://github.com/substack/tape" target="_blank" rel="external">tape</a> are simple, awesome testing tools for JavaScript. The JavaScript community has grown up with testing culture, and the vast majority of projects use larger tools like <a href="http://visionmedia.github.io/mocha/" target="_blank" rel="external">Mocha</a> and <a href="http://jasmine.github.io/" target="_blank" rel="external">Jasmine</a>. Recently I’ve been switching lots of projects over to tap &amp; tape, and want to share why.</p>
<p><a href="http://substack.net/" target="_blank" rel="external">substack</a>, the creator of tape, has already written a bit about <a href="http://substack.net/how_I_write_tests_for_node_and_the_browser" target="_blank" rel="external">his process</a> and thinking - here’s just a little more, written from the perspective of a former mocha user.</p>
<p>What it sorts down into is roughly three parts: the protocol, browserify, and magic.</p>
<h2 id="The_Test_Anything_Protocol">The Test Anything Protocol</h2><p>TAP, or the <a href="https://en.wikipedia.org/wiki/Test_Anything_Protocol" target="_blank" rel="external">Test Anything Protocol</a> is the definition of ‘tried &amp; true’: it’s been around since 1987 and has been implemented in <a href="https://en.wikipedia.org/wiki/Test_Anything_Protocol#List_of_TAP_producers" target="_blank" rel="external">a ton of languages</a>. It’s just a dead-simple way to format test results, like</p>
<pre><code>TAP version <span class="number">13</span>
<span class="preprocessor"># equivalence</span>
ok <span class="number">1</span> these two numbers are equal

<span class="number">1.</span><span class="number">.1</span>
<span class="preprocessor"># tests <span class="number">1</span></span>
<span class="preprocessor"># pass  <span class="number">1</span></span>

<span class="preprocessor"># ok</span>
</code></pre><p>Having this format be super simple means that you can combine tools that have common expectations. For instance, <a href="https://github.com/substack/faucet" target="_blank" rel="external">faucet</a> is a node module that gives pretty, summarized results for your tests, but it doesn’t directly plug into tape or node-tap - all it cares about is the TAP protocol, so you can pipe results into it. You could even pipe a <a href="http://testanything.org/producers.html" target="_blank" rel="external">TAP producer in a different language</a> into it, and it’ll work just the same.</p>
<h2 id="Browserify">Browserify</h2><p><a href="http://browserify.org/" target="_blank" rel="external">browserify</a> is another awesome tool written by <a href="http://substack.net/" target="_blank" rel="external">substack</a>. With it, you can use node-style require() calls in code you’re going to run in browsers, and then use the browserify command to stitch them all together and make something you can throw in a script tag.</p>
<p>Browserify has been huge for writing cross-platform libraries, and it’s been huge for building things. <a href="http://mapbox.com/" target="_blank" rel="external">Mapbox.com</a> and <a href="https://www.mapbox.com/mapbox.js/api/v1.6.1/" target="_blank" rel="external">Mapbox.js</a> are both constructed this way - individual libraries on npm, package.json just like nodejs code, and then browserify to bring it to the web.</p>
<p>Long story short, browserify ‘just works’ with tape. While mocha has something of an unusual browser story - it’s hard to get at the files you’d want to run tests in a browser, and then when you do, if you want to run tests in both browsers and node, it’s not straightforward to conditionally require things sometimes.</p>
<p>So, to run browserify tests in a browser, you can just run</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> browserify testling
$ browserify <span class="keyword">test</span>/<span class="keyword">test</span>.js | testling</span>
</code></pre><p>Simple as that. Since tape is just a node module and browserify turns the whole thing into just JavaScript, it’s easy to run it anywhere you want - embedded in a webpage, in a browser, or wherever. tape uses console.log to write its results, which is super easy to pull out of a headless browser.</p>
<h2 id="Concepts">Concepts</h2><p>A quick review: TAP is a standard for test output. node-tap and tape are two node modules that let you write tests that output results in the TAP protocol.</p>
<p>So, we’ve discussed TAP a little bit, and you might notice that mocha <a href="http://visionmedia.github.io/mocha/#tap-reporter" target="_blank" rel="external">supports TAP too</a>. So why not just use mocha to write tests? Let’s talk about that.</p>
<p>Magic</p>
<p><img src="/css/2015-06-25/2.jpg" alt=""></p>
<p>Mocha does a little magic. With only few exceptions, nodejs has the assumption that any variables on a page will come from obvious places:</p>
<pre><code><span class="comment">// this comes from a module</span>
<span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'module'</span>);
</code></pre><p>In the interest of simplicity, mocha doesn’t follow this rule. Your mocha test files have assumptions:</p>
<pre><code>var <span class="built_in">assert</span> = <span class="built_in">require</span>(<span class="string">"assert"</span>)
describe(<span class="string">'truth'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  it(<span class="string">'should find the truth'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="built_in">assert</span>.equal(<span class="number">1</span>, <span class="number">1</span>);
  })
})
</code></pre><p>Keen eyes will notice that assert entered the stage by a require() call, but describe and it didn’t - they appear magically.</p>
<p>On the other hand, a basic tape test:</p>
<pre><code><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">'tape'</span>).test;
test(<span class="string">'equivalence'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>{
    t.equal(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'these two numbers are equal'</span>);
    t.end();
});
</code></pre><p>test comes from require(), and t comes from the closure. Simple enough. This lack of abstraction has two awesome advantages:</p>
<p>1.It’s easier to form a mental model of what’s going on, so it’s easier to hack with it and know what’ll happen. What if I call a function with t and then call functions off of t? It’ll work.<br>2.Tests are code. So, you can run tests as modules with node, just like you’d run other code: node test/test.js, and it works. As opposed to needing a ‘test runner’ binary that contains some of the code the test really needs.</p>
<h2 id="Testling_&amp;_Travis-CI">Testling &amp; Travis-CI</h2><p><a href="http://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">Continuous Integration</a>, where every commit to <a href="https://github.com/" target="_blank" rel="external">GitHub</a> is automatically tested, has become a necessity. Setting the green ‘this works’ badge on projects means something, and we’ve found that running tests on remote hosts can give a better sanity check than just running them locally - the environment is constructed from scratch, there aren’t any stray files that make things work.</p>
<p>tape works with testling just like mocha - the same <a href="https://github.com/mapbox/wellknown/blob/master/.travis.yml" target="_blank" rel="external">minimal .travis.yml</a> file ‘just works’ as long as npm install and npm test do their things. But on top of that, you can use <a href="https://ci.testling.com/" target="_blank" rel="external">Testling-CI</a> and <a href="https://github.com/substack/testling" target="_blank" rel="external">testling</a>, and test commits in browsers. Testling-CI works the same as Travis: set a webhook, <a href="https://ci.testling.com/guide/quick_start" target="_blank" rel="external">tweak a few package.json properties</a>, and you’ll get a <a href="https://ci.testling.com/mapbox/wellknown" target="_blank" rel="external">page of your own with results</a>. testling, on the other hand, runs headless tests locally, with your real browsers, not with <a href="http://phantomjs.org/" target="_blank" rel="external">phantomjs</a> or another custom abstraction. In combination, this means that you can easily cross-browser test code. And if the abstractions break, it’s easy to just browserify the code and run the tests manually.</p>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/css/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/25/test/" data-id="cid190g3s000aam7fxaqf0kh5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-centos-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/25/centos-7/" class="article-date">
  <time datetime="2015-06-24T16:00:00.000Z" itemprop="datePublished">2015-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/25/centos-7/">centos7作为web服务器优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>centos7作为web服务器优化 </p>
<p>1、关闭firewalld： </p>
<pre><code>systemctl stop firewalld<span class="class">.service</span> #停止firewall
systemctl disable firewalld<span class="class">.service</span> #禁止firewall开机启动
</code></pre><p>2、安装iptables防火墙 </p>
<pre><code>yum <span class="keyword">install</span> iptables-services <span class="comment">#安装</span>
  iptables -nvL   <span class="comment">#查看信息</span>
</code></pre><p>3、加大打开文件数的限制（open files） </p>
<p>查看 </p>
<pre><code><span class="built_in">ulimit</span> -n
  <span class="built_in">ulimit</span> <span class="operator">-a</span>

  vi /etc/security/limits.conf
</code></pre><p>最后添加 </p>
<pre><code>* soft nofile <span class="number">1024000</span> 
* hard nofile <span class="number">1024000</span> 
hive   - nofile <span class="number">1024000</span> 
hive   - nproc  <span class="number">1024000</span> 
</code></pre><p>用户进程限制 </p>
<pre><code>vi /etc/security/limits.d/<span class="number">20</span>-nproc.conf

  <span class="preprocessor">#加大普通用户限制  也可以改为unlimited</span>
  *          soft    nproc     <span class="number">40960</span>
  root       soft    nproc     unlimited
</code></pre><p>此步骤需要重启机器生效，可以设置完后再重启 </p>
<p>4、网络线程优化 </p>
<pre><code><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span>
</code></pre><p>加入下面几行 </p>
<pre><code><span class="preprocessor"># Disable IPv6</span>
net.ipv6.conf.all.disable_ipv6 = <span class="number">1</span>
net.ipv6.conf.<span class="keyword">default</span>.disable_ipv6 = <span class="number">1</span>

<span class="preprocessor"># Determines how often to check for stale neighbor entries.</span>
net.ipv4.neigh.<span class="keyword">default</span>.gc_stale_time=<span class="number">120</span>

<span class="preprocessor"># Using arp_announce/arp_ignore to solve the ARP Problem</span>
net.ipv4.conf.<span class="keyword">default</span>.arp_announce = <span class="number">2</span>
net.ipv4.conf.all.arp_announce=<span class="number">2</span>
vm.swappiness = <span class="number">0</span>
net.ipv4.tcp_max_tw_buckets = <span class="number">5000</span>
net.ipv4.tcp_max_syn_backlog = <span class="number">1024</span>
net.ipv4.tcp_synack_retries = <span class="number">2</span>
net.ipv4.conf.lo.arp_announce=<span class="number">2</span>


net.ipv4.tcp_keepalive_time = <span class="number">1800</span>
net.ipv4.tcp_keepalive_probes = <span class="number">3</span>
net.ipv4.tcp_keepalive_intvl = <span class="number">15</span>

net.ipv4.tcp_syncookies = <span class="number">1</span>
net.ipv4.tcp_tw_reuse = <span class="number">1</span>
net.ipv4.tcp_tw_recycle = <span class="number">1</span>
net.ipv4.tcp_fin_timeout = <span class="number">30</span>


执行下面命令生效
/sbin/sysctl -p
</code></pre><p>5.时间校对 </p>
<pre><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime

  ntpdate us.pool.ntp.org


  crontab -e
  0-59/10 <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> /usr/sbin/ntpdate us.pool.ntp.org |<span class="string"> logger -t NTP

  service crond restart</span>
</code></pre><p>6.关闭root登录并修改ssh端口 </p>
<p><a href="http://linuxg.net/5-useradd-command-examples/" target="_blank" rel="external">http://linuxg.net/5-useradd-command-examples/</a></p>
<p>最常用的</p>
<pre><code>sudo useradd -<span class="keyword">m</span> -<span class="keyword">d</span> /home/mike1 -s /bin/bash -c <span class="string">"the mike1 user"</span> -<span class="keyword">U</span> mike1
</code></pre><p>添加普通用户 </p>
<pre><code>groupadd <span class="built_in">test</span>
  useradd <span class="operator">-d</span> /home/www/ -g <span class="built_in">test</span> <span class="built_in">test</span>1
  passwd <span class="built_in">test</span>1
</code></pre><p>iptables 开启6666端口  此步骤须先于下面步骤，否则会造成ssh连不上的 </p>
<pre><code>vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/iptables </span>
</code></pre><p>添加 </p>
<pre><code>-A INPUT -p tcp -m <span class="keyword">state</span> --state NEW -m tcp --dport <span class="number">6666</span> -j ACCEPT
</code></pre><p>修改ssh端口 </p>
<pre><code>vi <span class="regexp">/etc/</span>ssh<span class="regexp">/sshd_config </span>
</code></pre><p>找到#Port 22一段，这里是标识默认使用22端口，修改为如下： </p>
<pre><code><span class="preprocessor">#Port <span class="number">22</span> </span>
Port <span class="number">6666</span> 
</code></pre><p>关闭root登录权限<br>把</p>
<pre><code><span class="title">PermitRootLogin</span> <span class="built_in">yes</span>
</code></pre><p>改为</p>
<pre><code><span class="title">PermitRootLogin</span> <span class="built_in">no</span>
</code></pre><p>保存退出 </p>
<p>测试新用户能正常登录后方可以在iptables 禁用22端口了 </p>
<p>7.禁止开启ping </p>
<p>禁止</p>
<pre><code>echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/icmp_echo_ignore_all
</code></pre><p>开启</p>
<pre><code>echo <span class="number">0</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/icmp_echo_ignore_all
</code></pre><p>永久保存</p>
<pre><code>vi /etc/rc.d/rc.local
echo <span class="number">1</span> &gt;/<span class="keyword">proc</span>/sys/net/ipv4/icmp_echo_ignore_all
</code></pre><p>8.网络命令ifconfig </p>
<pre><code><span class="string">bash:</span> <span class="string">ifconfig:</span> 未找到命令
  yum -y install net-tools
</code></pre><p>9.nginx转发请求</p>
<pre><code>location / {
    proxy_set_header X-Real-IP <span class="variable">$remote</span>_addr;
    proxy_set_header X-Forwarded-For <span class="variable">$proxy</span>_add_x_forwarded_for;
    proxy_set_header Host <span class="variable">$http</span>_host;
    proxy_set_header X-NginX-Proxy true;
    proxy_pass http://<span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">3002</span>;
    proxy_redirect off;
}
</code></pre><p>10.资源</p>
<ul>
<li><a href="http://wiki.mikejung.biz/CentOS_7" target="_blank" rel="external">http://wiki.mikejung.biz/CentOS_7</a></li>
<li><a href="http://wiki.mikejung.biz/OS_Tuning" target="_blank" rel="external">http://wiki.mikejung.biz/OS_Tuning</a></li>
<li><a href="http://itgeeker.net/centos-7-minimal-optimization-10-ways-after-new-installation-by-itgeeker/" target="_blank" rel="external">http://itgeeker.net/centos-7-minimal-optimization-10-ways-after-new-installation-by-itgeeker/</a></li>
</ul>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/25/centos-7/" data-id="cid190g3v000cam7fygd2kah1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sails-vs-meteor-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/25/sails-vs-meteor-1/" class="article-date">
  <time datetime="2015-06-24T16:00:00.000Z" itemprop="datePublished">2015-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/25/sails-vs-meteor-1/">sails vs meteor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看一下sails的特性</p>
<ul>
<li><a href="http://www.sailsjs.org/#!/features" target="_blank" rel="external">http://www.sailsjs.org/#!/features</a></li>
</ul>
<h2 id="安装">安装</h2><pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> sails</span>
</code></pre><p>很简单就可以安装了。</p>
<h2 id="看一下它的帮助">看一下它的帮助</h2><pre><code>sails <span class="comment">--help</span>

 Usage: sails [<span class="command"><span class="keyword">command</span>]</span>

 Commands:

   <span class="built_in">version</span>               
   lift [options]        
   <span class="built_in">new</span> [options] [path_to_new_app]
   generate              
   console               
   consle                
   consloe               
   c                     
   www                   
   debug                 
   configure             
   help                  
   *                     

 Options:

   -h, <span class="comment">--help     output usage information</span>
   -v, <span class="comment">--version  output the version number</span>
   <span class="comment">--silent       </span>
   <span class="comment">--verbose      </span>
   <span class="comment">--silly  </span>
</code></pre><p>这是它的cli的全部功能</p>
<ul>
<li>new 是根据模板创建项目</li>
<li>generate 是教授叫生成</li>
<li>lift 是启动服务器</li>
</ul>
<p>了解这3个基本上就可以了。</p>
<p>如果你想进一步了解，可以继续看help</p>
<pre><code>sails lift --help

 Usage: lift [options]

 Options:

   -<span class="ruby">h, --help     output usage information
</span>   -<span class="ruby">-prod         
</span>   -<span class="ruby">-port [port]  </span>
</code></pre><h2 id="创建一个项目看看">创建一个项目看看</h2><pre><code>sails <span class="keyword">new</span> helloworld
<span class="keyword">cd</span> helloworld 
sails lift
</code></pre><p>我们需要看一下它的目录结构</p>
<pre><code>➜  helloworld  tree -L <span class="number">2</span>    
.
├── Gruntfile.js
├── README.md
├── api
│   ├── controllers
│   ├── models
│   ├── policies
│   ├── responses
│   └── services
├── app.js
├── assets
│   ├── favicon.ico
│   ├── images
│   ├── js
│   ├── robots.txt
│   ├── styles
│   └── templates
├── config
│   ├── blueprints.js
│   ├── bootstrap.js
│   ├── connections.js
│   ├── cors.js
│   ├── csrf.js
│   ├── env
│   ├── globals.js
│   ├── http.js
│   ├── i18n.js
│   ├── local.js
│   ├── locales
│   ├── log.js
│   ├── models.js
│   ├── policies.js
│   ├── routes.js
│   ├── session.js
│   ├── sockets.js
│   └── views.js
├── node_modules
│   ├── ejs -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/ejs
│   ├── grunt -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt
│   ├── grunt-contrib-clean -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-clean
│   ├── grunt-contrib-coffee -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-coffee
│   ├── grunt-contrib-concat -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-concat
│   ├── grunt-contrib-copy -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-copy
│   ├── grunt-contrib-cssmin -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-cssmin
│   ├── grunt-contrib-jst -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-jst
│   ├── grunt-contrib-less -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-less
│   ├── grunt-contrib-uglify -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-uglify
│   ├── grunt-contrib-watch -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-contrib-watch
│   ├── grunt-sails-linker -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-sails-linker
│   ├── grunt-sync -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/grunt-sync
│   ├── include-all -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/include-all
│   ├── rc -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/rc
│   ├── sails -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules/sails
│   └── sails-disk -&gt; <span class="regexp">/Users/</span>sang<span class="regexp">/.nvm/</span>v0<span class="number">.10</span><span class="number">.38</span><span class="regexp">/lib/</span>node_modules<span class="regexp">/sails/</span>node_modules/sails-disk
├── <span class="keyword">package</span>.json
├── tasks
│   ├── README.md
│   ├── config
│   ├── pipeline.js
│   └── register
└── views
    ├── <span class="number">403.</span>ejs
    ├── <span class="number">404.</span>ejs
    ├── <span class="number">500.</span>ejs
    ├── homepage.ejs
    └── layout.ejs

<span class="number">36</span> directories, <span class="number">29</span> files
</code></pre><h2 id="目录说明">目录说明</h2><p>app.js是入口，和express类似，但你看不到任何express的影子，它把东西都抽象到module里了，一般人看起来是有点难于理解的。</p>
<p>自己的代码要写在api目录里</p>
<pre><code>├── api
│   ├── controllers
│   ├── models
│   ├── policies
│   ├── responses
│   └── services
</code></pre><p>而rails是在app目录里。sails放到api里，可能是现在写api比较多，2点好处</p>
<ul>
<li>前后端分离</li>
<li>为移动端提供api</li>
</ul>
<p>这命名也是比较好理解的</p>
<ul>
<li>controllers和models是mvc里的m和c</li>
<li>services 一般是多model相关的业务操作，它只在controller里调用</li>
<li>responses比较有意思，它实际上是给res服务器响应对象增加方法，比如定义个aaa方法，你就可以res.aaa()了，对于扩展res是有好处的，算一个小亮点</li>
<li>policies 是权限控制部分，说白了也还是中间件，config.policies.js里声明权限，相信会玩死很多人，简单的acl还不如自己写</li>
</ul>
<p>至此，核心的特性已经从目录看的差不多了。</p>
<h2 id="node_modules">node_modules</h2><p>一般项目里做模块依赖，很烦。</p>
<p>rails里的bundle install也很烦。。。</p>
<p>但是sails利用软连接，把依赖的模块放到自己的npm安装目录，然后创建软连接，这样就可以在sails new之后，里面启动服务器，无需安装任何模块，这一点还是值得借鉴的</p>
<h2 id="views">views</h2><p>目录和express一样，它的默认模板引擎是ejs</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> View Engine Configuration
 <span class="keyword">*</span> (sails.config.views)
 <span class="keyword">*</span>
 <span class="keyword">*</span> Server-sent views are a classic and effective way to get your app up
 <span class="keyword">*</span> and running. Views are normally served from controllers.  Below, you can
 <span class="keyword">*</span> configure your templating language/framework of choice and configure
 <span class="keyword">*</span> Sails' layout support.
 <span class="keyword">*</span>
 <span class="keyword">*</span> For more information on views and layouts, check out:
 <span class="keyword">*</span> http://sailsjs.org/<span class="comment">#!/documentation/concepts/Views</span>
 <span class="keyword">*</span>/

module.exports.views = {
  engine: 'ejs',
  layout: 'layout',
  partials: false
};
</code></pre><p>各取所需吧，爱用啥用啥，比如又要掀起一场口水打仗了。。。。</p>
<h2 id="assets">assets</h2><p>asset pipeline其实最早也是rails里的概念，可以将JS和CSS合并和压缩</p>
<p>打开package.json</p>
<pre><code>"grunt": "<span class="operator">0.<span class="number">4.2</span><span class="string">",
"</span>grunt-contrib-clean<span class="string">": "</span>~<span class="number">0.5</span><span class="number">.0</span><span class="string">",
"</span>grunt-contrib-coffee<span class="string">": "</span>~<span class="number">0.10</span><span class="number">.1</span><span class="string">",
"</span>grunt-contrib-<span class="keyword">concat</span><span class="string">": "</span>~<span class="number">0.3</span><span class="number">.0</span><span class="string">",
"</span>grunt-contrib-copy<span class="string">": "</span>~<span class="number">0.5</span><span class="number">.0</span><span class="string">",
"</span>grunt-contrib-cssmin<span class="string">": "</span>~<span class="number">0.9</span><span class="number">.0</span><span class="string">",
"</span>grunt-contrib-jst<span class="string">": "</span>~<span class="number">0.6</span><span class="number">.0</span><span class="string">",
"</span>grunt-contrib-<span class="keyword">less</span><span class="string">": "</span><span class="number">0.11</span><span class="number">.1</span><span class="string">",
"</span>grunt-contrib-uglify<span class="string">": "</span>~<span class="number">0.4</span><span class="number">.0</span><span class="string">",
"</span>grunt-contrib-watch<span class="string">": "</span>~<span class="number">0.5</span><span class="number">.3</span><span class="string">",
"</span>grunt-sails-linker<span class="string">": "</span>~<span class="number">0.9</span><span class="number">.5</span><span class="string">",
"</span>grunt-<span class="keyword">sync</span><span class="string">": "</span>~<span class="number">0.0</span><span class="number">.4</span><span class="string">",</span></span>
</code></pre><p>从这里基本可以看出它的功能</p>
<ul>
<li>js支持coffeescript</li>
<li>css支持less</li>
<li>常用grunt操作，clean是清理，concat是合并，copy是复制，cssmin是压缩css，uglify是压缩js，watch是检测文件变动，sync应该是类似livereload之类的模块</li>
</ul>
<p>后来发现它的文档里也有</p>
<p>Here are a few things that the default Grunt configuration in Sails does to help you out:</p>
<ul>
<li>Automatic LESS compilation</li>
<li>Automatic JST compilation</li>
<li>Automatic Coffeescript compilation</li>
<li>Optional automatic asset injection, minification, and concatenation</li>
<li>Creation of a web ready public directory</li>
<li>File watching and syncing</li>
<li>Optimization of assets in production</li>
</ul>
<p>多了一个jst编译，是<code>grunt-contrib-jst</code>做的事儿，其他大致一样</p>
<p>默认它是没有grunt-cli模块的,需要自己安装</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> grunt-cli</span>
</code></pre><p>然后执行grunt命令</p>
<pre><code>➜  helloworld  grunt       
Running <span class="string">"clean:dev"</span> (clean) <span class="keyword">task</span>
Cleaning <span class="typename">.tmp</span><span class="keyword">/</span>public..<span class="typename">.OK</span>

Running <span class="string">"jst:dev"</span> (jst) <span class="keyword">task</span>
<span class="keyword">&gt;</span><span class="keyword">&gt;</span> Destination <span class="keyword">not</span> written because compiled files were empty.

Running <span class="string">"less:dev"</span> (less) <span class="keyword">task</span>
File <span class="typename">.tmp</span><span class="keyword">/</span>public<span class="keyword">/</span>styles<span class="keyword">/</span>importer<span class="typename">.css</span> created<span class="keyword">:</span> <span class="number">0</span> B → <span class="number">619</span> B

Running <span class="string">"copy:dev"</span> (copy) <span class="keyword">task</span>
Copied <span class="number">3</span> files

Running <span class="string">"coffee:dev"</span> (coffee) <span class="keyword">task</span>

Running <span class="string">"sails-linker:devJs"</span> (sails<span class="keyword">-</span>linker) <span class="keyword">task</span>
padding length <span class="number">4</span>
File <span class="string">"views/layout.ejs"</span> updated.

Running <span class="string">"sails-linker:devStyles"</span> (sails<span class="keyword">-</span>linker) <span class="keyword">task</span>
padding length <span class="number">4</span>
File <span class="string">"views/layout.ejs"</span> updated.

Running <span class="string">"sails-linker:devTpl"</span> (sails<span class="keyword">-</span>linker) <span class="keyword">task</span>
padding length <span class="number">4</span>
File <span class="string">"views/layout.ejs"</span> updated.

Running <span class="string">"sails-linker:devJsJade"</span> (sails<span class="keyword">-</span>linker) <span class="keyword">task</span>

Running <span class="string">"sails-linker:devStylesJade"</span> (sails<span class="keyword">-</span>linker) <span class="keyword">task</span>

Running <span class="string">"sails-linker:devTplJade"</span> (sails<span class="keyword">-</span>linker) <span class="keyword">task</span>

Running <span class="string">"watch"</span> <span class="keyword">task</span>
Waiting...
</code></pre><p>这里就是grunt的tasks了，没有啥可说的，我不是很喜欢grunt，我更喜欢gulp，sails默认是grunt，但文档里有有gulp版本的，可以去试试</p>
<p>另外要说明的是上线的时候，静态资源处理</p>
<ul>
<li>要么cdn</li>
<li>要么nginx反向代理</li>
</ul>
<p>这东西的价值就非常好了。</p>
<h2 id="config">config</h2><p>太多了，蛋疼。。。。</p>
<h2 id="console">console</h2><pre><code>sails <span class="built_in">console</span>
</code></pre><p>是通过命令行来处理数据的，一般简单测试会用</p>
<p>测试模型以及orm方法还是很爽的</p>
<h2 id="来个例子玩玩吧">来个例子玩玩吧</h2><p>生成controller玩玩</p>
<pre><code>sails generate controller comment <span class="operator"><span class="keyword">create</span> destroy tag <span class="keyword">like</span></span>
</code></pre><p>生成的代码</p>
<pre><code><span class="comment">/**
 * CommentController
 *
 * @description :: Server-side logic for managing comments
 * @help        :: See http://sailsjs.org/#!/documentation/concepts/Controllers
 */</span>

<span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> {



  <span class="comment">/**
   * `CommentController.create()`
   */</span>
  create: <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> {</span>
    return res.json<span class="params">({
      todo: 'create<span class="params">()</span> is not implemented yet!'
    })</span>;
  },


  <span class="comment">/**
   * `CommentController.destroy()`
   */</span>
  destroy: <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> {</span>
    return res.json<span class="params">({
      todo: 'destroy<span class="params">()</span> is not implemented yet!'
    })</span>;
  },


  <span class="comment">/**
   * `CommentController.tag()`
   */</span>
  tag: <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> {</span>
    return res.json<span class="params">({
      todo: 'tag<span class="params">()</span> is not implemented yet!'
    })</span>;
  },


  <span class="comment">/**
   * `CommentController.like()`
   */</span>
  like: <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> {</span>
    return res.json<span class="params">({
      todo: 'like<span class="params">()</span> is not implemented yet!'
    })</span>;
  }
};
</code></pre><p>这种意义不是很大。。。</p>
<p>生成模型</p>
<pre><code>sails generate model user <span class="property">name</span>:<span class="type">string</span> email:<span class="type">string</span> password:<span class="type">string</span>
</code></pre><p>基于Waterline的，除了可以适配多个db外，没看出啥特别的，写法一点也不好</p>
<p>如果直接生成api呢</p>
<pre><code>➜  helloworld  sails generate api sssd sdf jklsdf werjk jlksd sd 
<span class="string">info:</span> Created a <span class="keyword">new</span> api!
</code></pre><p>擦，生成SssdController，每一个属性生成一个方法</p>
<p>Sssd model里只有属性对。。。。哭了</p>
<p>另外把路由配置在config.routes.js里，声明式做法也蛮蛋疼的，太麻烦了。。。。</p>
<p>另外说基于blueprints的restful api，恕我愚钝，没太看明白</p>
<p>难道</p>
<pre><code><span class="title">sails</span> generate api dentist
</code></pre><p>所有的代码都隐掉，你无法做任何修改么？</p>
<h2 id="orm">orm</h2><ul>
<li>强大的关联</li>
<li>console 调试</li>
</ul>
<p>如果一个orm，在js的语法下，兼容Any database，你说能不恶心么？把nosql和rdbms搞到一起，Waterline也是醉了。。。</p>
<p>他们还自己吹牛</p>
<ul>
<li>activerecord</li>
<li>hibernate</li>
</ul>
<p>类的。。。</p>
<p>凑合用吧</p>
<h2 id="总结">总结</h2><p>sails能做到这样已经很不错了，有很多点都是和rails概念类似，也很用心</p>
<p>但出于js语法以及各种db等，还是有很多难受的地方</p>
<p>项目选型思考</p>
<ul>
<li>如果有熟悉rails思想的人可以考虑用</li>
<li>如果有大牛可以用</li>
<li>如果是新手或者无人解决框架问题，还是老老实实的express吧</li>
</ul>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/25/sails-vs-meteor-1/" data-id="cid190g3u000bam7fsmcxz6db" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mongodb-ttl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/19/mongodb-ttl/" class="article-date">
  <time datetime="2015-06-18T16:00:00.000Z" itemprop="datePublished">2015-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/19/mongodb-ttl/">mongodb的ttl</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>TTL是 Time To Live的缩写，译为生存时间。<br>TTL Collection(淘汰过期数据)</p>
<p>MongoDB 2.2 引入一个新特性 —— TTL 集合，TTL 集合支持失效时间设置，当超过指定时间后，集合自动清除超时的文档，这用来保存一些诸如session会话信息的时候非常有用，或者存储缓存数据使用。</p>
<p>如果你想使用 TTL 集合，你要用到 expireAfterSeconds 选项： </p>
<pre><code>db.ttl.ensureIndex({<span class="string">"Date"</span>: <span class="number">1</span>}, {expireAfterSeconds: <span class="number">300</span>})
</code></pre><h2 id="限制">限制</h2><p>使用 TTL 集合时是有限制的： </p>
<ul>
<li>你不能创建 TTL 索引，如果要索引的字段已经在其他索引中使用</li>
<li>索引不能包含多个字段</li>
<li>索引的字段必须是一个日期的 bson 类型</li>
</ul>
<p>如果你违反了上述三个规则，那么超时后文档不会被自动清除。</p>
<h2 id="文档是怎么被删除的？">文档是怎么被删除的？</h2><p>mongod 后台进程会实时跟踪过期的文档并删除，我们来对此进行检查测试：</p>
<p>首先我们创建一个索引并设置 10 秒钟后失效：</p>
<pre><code>db.ttl_collection.ensureIndex( { <span class="string">"Date"</span>: <span class="number">1</span> }, { expireAfterSeconds: <span class="number">10</span> } )
</code></pre><p>然后插入文档：</p>
<pre><code>db.ttl_collection.insert({<span class="string">"Date"</span> : <span class="keyword">new</span> Date()})
</code></pre><p>因为我们想象该文档会在 10 秒后删除，可是我在我的电脑上测试多次，结果却不太一样。</p>
<p>有些时候 mongod 在 18 秒后删除，有些时候是 40 秒。</p>
<p>为什么会这样呢？我们已经告诉 MongoDB 要在 10 秒后删除，可事实上却不是如此。 </p>
<p>例如，这一次是 45 秒中后才删除： </p>
<p>因为 mongod 后台任务每分钟检查一次过期文档，因此在时间的处理上总有一定的差异，但这个差异不会超过 1 分钟，这也取决于 MongoDB 实例当前的负荷情况。 </p>
<h2 id="mongo_session">mongo session</h2><pre><code>{
  "<span class="attribute">_id</span>": <span class="value"><span class="string">"L3b_elXZtbDBxOkwFICHyBvfn7etKiJP"</span></span>,
  "<span class="attribute">session</span>": <span class="value">{
    "<span class="attribute">cookie</span>": <span class="value">{
      "<span class="attribute">originalMaxAge</span>": <span class="value"><span class="number">1800000</span></span>,
      "<span class="attribute">expires</span>": <span class="value"><span class="string">"2015-06-19T09:16:49.469Z"</span></span>,
      "<span class="attribute">secure</span>": <span class="value"><span class="literal">false</span></span>,
      "<span class="attribute">httpOnly</span>": <span class="value"><span class="literal">true</span></span>,
      "<span class="attribute">path</span>": <span class="value"><span class="string">"/"</span>
    </span>}</span>,
    "<span class="attribute">current_user</span>": <span class="value">{
      "<span class="attribute">_id</span>": <span class="value"><span class="string">"55783c18ad0e6c3e1bb03399"</span></span>,
      "<span class="attribute">username</span>": <span class="value"><span class="string">"kezhi"</span></span>,
      "<span class="attribute">password</span>": <span class="value"><span class="string">"111111"</span></span>,
      "<span class="attribute">__v</span>": <span class="value"><span class="number">0</span>
    </span>}
  </span>}</span>,
  "<span class="attribute">expires</span>": <span class="value">ISODate(<span class="string">"2015-06-19T09:16:49.524Z"</span>)
</span>}
</code></pre><p>好奇怪，我刚建立的session</p>
<pre><code>db.sessions.stats()


{
    <span class="string">"ns"</span> : <span class="string">"vsq.sessions"</span>,
    <span class="string">"count"</span> : <span class="number">1</span>,
    <span class="string">"size"</span> : <span class="number">240</span>,
    <span class="string">"avgObjSize"</span> : <span class="number">240</span>,
    <span class="string">"numExtents"</span> : <span class="number">1</span>,
    <span class="string">"storageSize"</span> : <span class="number">8192</span>,
    <span class="string">"lastExtentSize"</span> : <span class="number">8192</span>,
    <span class="string">"paddingFactor"</span> : <span class="number">1</span>,
    <span class="string">"paddingFactorNote"</span> : <span class="string">"paddingFactor is unused and unmaintained in 3.0. It remains hard coded to 1.0 for compatibility only."</span>,
    <span class="string">"userFlags"</span> : <span class="number">1</span>,
    <span class="string">"capped"</span> : <span class="literal">false</span>,
    <span class="string">"nindexes"</span> : <span class="number">2</span>,
    <span class="string">"indexDetails"</span> : {},
    <span class="string">"totalIndexSize"</span> : <span class="number">16352</span>,
    <span class="string">"indexSizes"</span> : {
        <span class="string">"_id_"</span> : <span class="number">8176</span>,
        <span class="string">"expires_1"</span> : <span class="number">8176</span>
    },
    <span class="string">"ok"</span> : <span class="number">1</span>
}
</code></pre><p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/19/mongodb-ttl/" data-id="cid190g3w000dam7fzig6bnhd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-koa-or-express" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/17/koa-or-express/" class="article-date">
  <time datetime="2015-06-16T16:00:00.000Z" itemprop="datePublished">2015-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/17/koa-or-express/">Koa 还是 Express？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>群里很多人在问到底该用Koa还是express，本文会对比2个框架的各种细节，并给出指导意见，希望能够为大家解惑。</p>
<ul>
<li><a href="http://koajs.com/" target="_blank" rel="external">http://koajs.com/</a></li>
<li><a href="http://expressjs.com/" target="_blank" rel="external">http://expressjs.com/</a></li>
</ul>
<h2 id="koa">koa</h2><p>koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p>
<h3 id="版本要求">版本要求</h3><p>Koa 目前需要 &gt;=0.11.x版本的 node 环境。并需要在执行 node 的时候附带 –harmony 来引入 generators 。 </p>
<p>express无所谓，目前0.10+都ok，甚至更低版本</p>
<h3 id="中间件变化">中间件变化</h3><p>Koa 应用是一个包含一系列中间件 generator 函数的对象。 这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。 Koa 类似于其他中间件系统（比如 Ruby’s Rack 、Connect 等）， 然而 Koa 的核心设计思路是为中间件层提供高级语法糖封装，以增强其互用性和健壮性，并使得编写中间件变得相当有趣。</p>
<p>Koa 包含了像 content-negotiation（内容协商）、cache freshness（缓存刷新）、proxy support（代理支持）和 redirection（重定向）等常用任务方法。 与提供庞大的函数支持不同，Koa只包含很小的一部分，因为Koa并不绑定任何中间件。</p>
<p>和 express 基于的中间件Connect，差别并不大，思想都是一样的，它里面说的</p>
<pre><code>增强其互用性和健壮性
</code></pre><p>我还没玩出太多感想，请大家指点</p>
<p>除了<code>yield next;</code>外，并无其他</p>
<p>yield要说一下，必须在处理的中间件里才会回调</p>
<p>比如</p>
<pre><code><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);
<span class="keyword">var</span> app = koa();

<span class="comment">//1 x-response-time</span>

app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>{
  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;
  <span class="keyword">yield</span> next;
  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;
  <span class="keyword">this</span>.set(<span class="string">'X-Response-Time'</span>, ms + <span class="string">'ms'</span>);
});

<span class="comment">//2 logger</span>

app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>{
  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;
  <span class="keyword">yield</span> next;
  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;
  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);
});

<span class="comment">//3 response</span>

app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>{
  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;
});

app.listen(<span class="number">3000</span>);
</code></pre><p>在程序启动的时候，1和2是没有执行的，只有当执行到任意请求，比如3的时候，它才会调用1和2</p>
<h2 id="错误处理">错误处理</h2><p>koa</p>
<pre><code><span class="keyword">app</span>.<span class="keyword">on</span>('<span class="keyword">error</span>', function(<span class="keyword">err</span>){
  <span class="keyword">log</span>.<span class="keyword">error</span>('server <span class="keyword">error</span>', <span class="keyword">err</span>);
});
</code></pre><p>而在新版的express里</p>
<pre><code>server.on(<span class="string">'error'</span>, onError);


<span class="comment">/**
 * Event listener for HTTP server "error" event.
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">error</span>) </span>{
  <span class="keyword">if</span> (error.syscall !== <span class="string">'listen'</span>) {
    <span class="keyword">throw</span> error;
  }

  <span class="keyword">var</span> bind = <span class="keyword">typeof</span> port === <span class="string">'string'</span>
    ? <span class="string">'Pipe '</span> + port
    : <span class="string">'Port '</span> + port;

  <span class="comment">// handle specific listen errors with friendly messages</span>
  <span class="keyword">switch</span> (error.code) {
    <span class="keyword">case</span> <span class="string">'EACCES'</span>:
      <span class="built_in">console</span>.error(bind + <span class="string">' requires elevated privileges'</span>);
      process.exit(<span class="number">1</span>);
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'EADDRINUSE'</span>:
      <span class="built_in">console</span>.error(bind + <span class="string">' is already in use'</span>);
      process.exit(<span class="number">1</span>);
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      <span class="keyword">throw</span> error;
  }
}
</code></pre><p>二者实际上没有啥大差别</p>
<h3 id="Koa_Context">Koa Context</h3><p>将 node 的 request 和 response 对象封装在一个单独的对象里面，其为编写 web 应用和 API 提供了很多有用的方法。</p>
<p>这些操作在 HTTP 服务器开发中经常使用，因此其被添加在上下文这一层，而不是更高层框架中，因此将迫使中间件需要重新实现这些常用方法。</p>
<p>context 在每个 request 请求中被创建，在中间件中作为接收器(receiver)来引用，或者通过 this 标识符来引用：</p>
<pre><code>app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>{
  <span class="keyword">this</span>; <span class="comment">// is the Context</span>
  <span class="keyword">this</span>.request; <span class="comment">// is a koa Request</span>
  <span class="keyword">this</span>.response; <span class="comment">// is a koa Response</span>
});
</code></pre><p>比express里爽一些，express里中间件可变参数还是会比较恶心，而且性能也不好</p>
<h3 id="对比一些api">对比一些api</h3><ul>
<li>req</li>
<li>res</li>
</ul>
<p>基本上一模一样</p>
<h3 id="二者比较总结">二者比较总结</h3><p><a href="https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md" target="_blank" rel="external">https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md</a></p>
<table>
<thead>
<tr>
<th style="text-align:right">Feature</th>
<th>Koa</th>
<th>Express</th>
<th>Connect</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Middleware Kernel</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td style="text-align:right">Routing</td>
<td></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td style="text-align:right">Templating</td>
<td></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td style="text-align:right">Sending Files</td>
<td></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td style="text-align:right">JSONP</td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Does Koa replace Express?</p>
<p>It’s more like Connect, but a lot of the Express goodies were moved to the middleware level in Koa to help form a stronger foundation. This makes middleware more enjoyable and less error-prone to write, for the entire stack, not just the end application code.</p>
<p>Typically many middleware would re-implement similar features, or even worse incorrectly implement them, when features like signed cookie secrets among others are typically application-specific, not middleware specific.</p>
<p>拿koa来比较express并不太合适，可以说它是介于connect和express中间的框架</p>
<ul>
<li>与connect类似都是调用栈思想，但修改了中间件模式，使用generator</li>
<li>把express里的一些好的东西加进去，但剔除了路由，视图渲染等特性</li>
</ul>
<h2 id="总结">总结</h2><p>koa是一个比express更精简，使用node新特性的中间件框架，相比之前express就是一个庞大的框架</p>
<ul>
<li>如果你喜欢diy，很潮，可以考虑koa，它有足够的扩展和中间件，而且自己写很简单</li>
<li>如果你想简单点，找一个框架啥都有，那么先express</li>
</ul>
<p>koa是大势所趋，我很想用，但我目前没有选koa，我的考虑</p>
<ul>
<li>0.11下我目前没有搞定node-inspector，所以我啥时候搞定，啥时候迁移</li>
<li>团队成本问题，如果他们连express都不会，上来就koa，学习曲线太逗，不合适</li>
<li>目前基于express的快读开发框架需要一段时间迁移到koa</li>
</ul>
<p>和es6的考虑是一样的，又爱又恨，先做技术储备，只要时机ok，毫不犹豫的搞起。</p>
<p>目前express由strongloop负责，它的下一步如何发展，还说不好，比如5.0、6.0是否会用koa作为中间件也不好说</p>
<p>koa代码很少，可以很容易读完</p>
<p><a href="https://github.com/koajs/koa" target="_blank" rel="external">https://github.com/koajs/koa</a></p>
<p>另外值得提得一点是，核心开发者 @dead-horse 是阿里的员工，赞一下国内的开源。</p>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/17/koa-or-express/" data-id="cid190g3x000eam7f924b86nm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sysstat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/15/sysstat/" class="article-date">
  <time datetime="2015-06-14T16:00:00.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/sysstat/">Sysstat</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Sysstat 是一个软件包，包含监测系统性能及效率的一组工具，这些工具对于我们收集系统性能数据，比如CPU使用率、硬盘和网络吞吐数据，这些数据的收集和分析，有利于我们判断系统是否正常运行，是提高系统运行效率、安全运行服务器的得力助手；</p>
<h2 id="install">install</h2><pre><code>wget http:<span class="comment">//pagesperso-orange.fr/sebastien.godard/sysstat-11.1.5.tar.gz</span>
cd sysstat-<span class="number">11.1</span><span class="number">.5</span>
./configure
make
sudo make install
</code></pre><h2 id="可用命令">可用命令</h2><p>Sysstat 软件包集成如下工具：</p>
<pre><code><span class="bullet">* </span>iostat 工具提供CPU使用率及硬盘吞吐效率的数据；
<span class="bullet">* </span>mpstat 工具提供单个处理器或多个处理器相关数据；
<span class="bullet">* </span>sar 工具负责收集、报告并存储系统活跃的信息；
<span class="bullet">* </span>sa1 工具负责收集并存储每天系统动态信息到一个二进制的文件中。它是通过计划任务工具cron来运行，
<span class="code">    是为sadc所设计的程序前端程序；</span>
<span class="bullet">* </span>sa2 工具负责把每天的系统活跃性息写入总结性的报告中。它是为sar所设计的前端 ，要通过cron来调用
<span class="bullet">* </span>sadc 是系统动态数据收集工具，收集的数据被写一个二进制的文件中，它被用作sar工具的后端；
<span class="bullet">* </span>sadf 显示被sar通过多种格式收集的数据；
</code></pre><h2 id="用法说明">用法说明</h2><ul>
<li><a href="http://sebastien.godard.pagesperso-orange.fr/tutorial.html" target="_blank" rel="external">http://sebastien.godard.pagesperso-orange.fr/tutorial.html</a></li>
<li><a href="http://www.eygle.com/digest/2007/07/linux_sysstat.html" target="_blank" rel="external">http://www.eygle.com/digest/2007/07/linux_sysstat.html</a></li>
</ul>
<h3 id="sar">sar</h3><pre><code><span class="keyword">man</span> sar
</code></pre><p>sar - Collect, report, or save system activity information.</p>
<pre><code>[deploy@iZ251uvtr2b ~]$ sar -u -o datafile <span class="number">2</span> <span class="number">3</span>
Linux <span class="number">3.10</span><span class="number">.0</span>-<span class="number">229.4</span><span class="number">.2</span>.el7.x86_64 (iZ251uvtr2bZ)     <span class="number">06</span>/<span class="number">15</span>/<span class="number">2015</span>     _x86_64_    (<span class="number">4</span> CPU)

<span class="number">11</span>:<span class="number">34</span>:<span class="number">42</span> AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
<span class="number">11</span>:<span class="number">34</span>:<span class="number">44</span> AM     all      <span class="number">0.13</span>      <span class="number">0.00</span>      <span class="number">0.13</span>      <span class="number">0.00</span>      <span class="number">0.00</span>     <span class="number">99.75</span>
<span class="number">11</span>:<span class="number">34</span>:<span class="number">46</span> AM     all      <span class="number">0.13</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>     <span class="number">99.87</span>
<span class="number">11</span>:<span class="number">34</span>:<span class="number">48</span> AM     all      <span class="number">0.13</span>      <span class="number">0.00</span>      <span class="number">0.13</span>      <span class="number">0.13</span>      <span class="number">0.00</span>     <span class="number">99.62</span>
Average:        all      <span class="number">0.13</span>      <span class="number">0.00</span>      <span class="number">0.08</span>      <span class="number">0.04</span>      <span class="number">0.00</span>     <span class="number">99.75</span>
</code></pre><h2 id="关于_Sysstat_计划任务">关于 Sysstat 计划任务</h2><p>crontab即可，没啥特殊的</p>
<h2 id="分享一些资源">分享一些资源</h2><ul>
<li><a href="http://thenodeway.io/posts/understanding-error-first-callbacks/" target="_blank" rel="external">http://thenodeway.io/posts/understanding-error-first-callbacks/</a></li>
<li><p><a href="http://thenodeway.io/posts/testing-essentials/" target="_blank" rel="external">http://thenodeway.io/posts/testing-essentials/</a></p>
</li>
<li><p><a href="http://thenodeway.io/posts/designing-singletons/" target="_blank" rel="external">http://thenodeway.io/posts/designing-singletons/</a></p>
</li>
<li><a href="http://thenodeway.io/posts/designing-custom-types/" target="_blank" rel="external">http://thenodeway.io/posts/designing-custom-types/</a></li>
<li><p><a href="http://thenodeway.io/posts/designing-factories/" target="_blank" rel="external">http://thenodeway.io/posts/designing-factories/</a></p>
</li>
<li><p><a href="http://thenodeway.io/posts/how-require-actually-works/" target="_blank" rel="external">http://thenodeway.io/posts/how-require-actually-works/</a></p>
</li>
<li><a href="http://thenodeway.io/posts/dangerous-module-design-patterns/" target="_blank" rel="external">http://thenodeway.io/posts/dangerous-module-design-patterns/</a></li>
</ul>
<p>ionic 分享到微信的例子，还不错</p>
<ul>
<li><a href="http://xingzhewujiang.org/press/add-wechat-share-to-cordova-ionic-angularjs-based-app.html" target="_blank" rel="external">http://xingzhewujiang.org/press/add-wechat-share-to-cordova-ionic-angularjs-based-app.html</a></li>
</ul>
<p>pixi 是 Super fast HTML 5 2D rendering engine that uses webGL with canvas fallback</p>
<p>h5游戏引擎</p>
<p><a href="https://github.com/GoodBoyDigital/pixi.js" target="_blank" rel="external">https://github.com/GoodBoyDigital/pixi.js</a></p>
<p>它比较有意思是的gulp的加载，<a href="https://github.com/GoodBoyDigital/pixi.js/tree/master/gulp/tasks" target="_blank" rel="external">https://github.com/GoodBoyDigital/pixi.js/tree/master/gulp/tasks</a></p>
<p>它使用的是require-dir来加载的，我也写了一个</p>
<ul>
<li>mount-tasks <a href="https://github.com/moajs/mount-tasks" target="_blank" rel="external">https://github.com/moajs/mount-tasks</a></li>
</ul>
<p>示例</p>
<pre><code><span class="keyword">var</span> gulp        = <span class="built_in">require</span>(<span class="string">'gulp'</span>);

<span class="comment">// Require all tasks in vendor/tasks, including subfolders</span>
<span class="built_in">require</span>(<span class="string">'mount-tasks'</span>)(__dirname + <span class="string">'/tasks'</span>)

<span class="comment">// default task</span>
gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>, <span class="string">'build'</span>]);
</code></pre><h2 id="好的开源项目">好的开源项目</h2><p><a href="https://github.com/chmontgomery/gulp-help" target="_blank" rel="external">https://github.com/chmontgomery/gulp-help</a></p>
<p>它很好的把cli的模式引入到gulp插件了</p>
<p>通过</p>
<pre><code>gulp <span class="built_in">help</span>
</code></pre><p>给对应的task增加说明描述信息，使其更具有可读性</p>
<p><a href="https://github.com/nodeonly/Chart.js" target="_blank" rel="external">https://github.com/nodeonly/Chart.js</a></p>
<p>演示<a href="http://www.chartjs.org/" target="_blank" rel="external">http://www.chartjs.org/</a></p>
<p>基于canvas绘制的图表工具，天生h5，支持响应式，基本图表该有的都有</p>
<p>最让我吃惊的是它又将近15000个star。。。。</p>
<p><a href="https://github.com/meteoric/meteor-ionic" target="_blank" rel="external">https://github.com/meteoric/meteor-ionic</a></p>
<p>Ionic components for Meteor. No Angular!<br><a href="http://meteoric.github.io" target="_blank" rel="external">http://meteoric.github.io</a></p>
<p>整合2个怪兽，不过还是很好用的，这个栈很潮，如果你搞的定，可以试试</p>
<h2 id="地区问题">地区问题</h2><p>东莞不支持子区域，比如厚街镇这样的地方是没有，需要手动添加</p>
<p>另外像太仓市，实际上是江苏苏州的地级市，但是客户并不清楚，所以级联选择地址是有很多弊病的。</p>
<p>还是需要更智能一点的组件。</p>
<h2 id="状态问题">状态问题</h2><p>今天发现一些数据不对，是因为状态跳转，之前有状态0，但现在状态0和1合并为1，所以0成了孤儿。</p>
<p>那么查询的时候，如果没有状态 in （1，2，3），那么你肯定会把0查出来，这样就会导致数据问题，非常难差</p>
<p>所以防御式编程的时候，需要处理in这样的方式</p>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/15/sysstat/" data-id="cid190g3x000fam7fx21zje69" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-node-restful-api" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/14/node-restful-api/" class="article-date">
  <time datetime="2015-06-13T16:00:00.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/node-restful-api/">Nodejs RESTFul架构实践之api</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="why_token_based_auth?">why token based auth?</h2><p>此段摘自 </p>
<ul>
<li><a href="http://zhuanlan.zhihu.com/FrontendMagazine/19920223" target="_blank" rel="external">http://zhuanlan.zhihu.com/FrontendMagazine/19920223</a></li>
</ul>
<p>英文原文</p>
<ul>
<li><a href="http://code.tutsplus.com/tutorials/token-based-authentication-with-angularjs-nodejs--cms-22543" target="_blank" rel="external">http://code.tutsplus.com/tutorials/token-based-authentication-with-angularjs-nodejs--cms-22543</a></li>
</ul>
<p>在讨论了关于基于 token 认证的一些基础知识后，我们接下来看一个实例。看一下下面的几点，然后我们会仔细的分析它：</p>
<p><img src="/img/2015-06-14/1.jpg" alt=""></p>
<ol>
<li>多个终端，比如一个 web 应用，一个移动端等向 API 发送特定的请求。</li>
<li>类似 <a href="https://api.yourexampleapp.com" target="_blank" rel="external">https://api.yourexampleapp.com</a> 这样的请求发送到服务层。如果很多人使用了这个应用，需要多个服务器来响应这些请求操作。</li>
<li>这时，负载均衡被用于平衡请求，目的是达到最优化的后端应用服务。当你向 <a href="https://api.yourexampleapp.com" target="_blank" rel="external">https://api.yourexampleapp.com</a> 发送请求，最外层的负载均衡会处理这个请求，然后重定向到指定的服务器。</li>
<li>一个应用可能会被部署到多个服务器上（server-1, server-2, …, server-n）。当有请求发送到<a href="https://api.yourexampleapp.com" target="_blank" rel="external">https://api.yourexampleapp.com</a> 时，后端的应用会拦截这个请求头部并且从认证头部中提取到 token 信息。使用这个 token 查询数据库。如果这个 token 有效并且有请求终端数据所必须的许可时，请求会继续。如果无效，会返回 403 状态码（表明一个拒绝的状态）。</li>
</ol>
<p>基于 token 的认证在解决棘手的问题时有几个优势：</p>
<ul>
<li>Client Independent Services 。在基于 token 的认证，token 通过请求头传输，而不是把认证信息存储在 session 或者 cookie 中。这意味着无状态。你可以从任意一种可以发送 HTTP 请求的终端向服务器发送请求。</li>
<li>CDN 。在绝大多数现在的应用中，view 在后端渲染，HTML 内容被返回给浏览器。前端逻辑依赖后端代码。这中依赖真的没必要。而且，带来了几个问题。比如，你和一个设计机构合作，设计师帮你完成了前端的 HTML，img 和 JavaScript，你需要拿到前端代码并且把它移植到你的后端代码中，目的当然是为了渲染。修改几次后，你渲染的 HTML 内容可能和设计师完成的代码有了很大的不同。在基于 token 的认证中，你可以开发完全独立于后端代码的前端项目。后端代码会返回一个 JSON 而不是渲染 HTML，并且你可以把最小化，压缩过的代码放到 CDN 上。当你访问 web 页面，HTML 内容由 CDN 提供服务，并且页面内容是通过使用认证头部的 token 的 API 服务所填充。</li>
<li>No Cookie-Session (or No CSRF) 。CSRF 是当代 web 安全中一处痛点，因为它不会去检查一个请求来源是否可信。为了解决这个问题，一个 token 池被用在每次表单请求时发送相关的 token。在基于 token 的认证中，已经有一个 token 应用在认证头部，并且 CSRF 不包含那个信息。</li>
<li>Persistent Token Store 。当在应用中进行 session 的读，写或者删除操作时，会有一个文件操作发生在操作系统的temp 文件夹下，至少在第一次时。假设有多台服务器并且 session 在第一台服务上创建。当你再次发送请求并且这个请求落在另一台服务器上，session 信息并不存在并且会获得一个“未认证”的响应。我知道，你可以通过一个粘性 session 解决这个问题。然而，在基于 token 的认证中，这个问题很自然就被解决了。没有粘性 session 的问题，因为在每个发送到服务器的请求中这个请求的 token 都会被拦截。</li>
</ul>
<p>这些就是基于 token 的认证和通信中最明显的优势。基于 token 认证的理论和架构就说到这里。下面上实例。</p>
<p>这段本来想自己写，不过自己写也这些内容，节省点时间</p>
<h2 id="jwt加密和解密">jwt加密和解密</h2><p>JWT 代表 JSON Web Token ，它是一种用于认证头部的 token 格式。这个 token 帮你实现了在两个系统之间以一种安全的方式传递信息。出于教学目的，我们暂且把 JWT 作为“不记名 token”。一个不记名 token 包含了三部分：header，payload，signature。</p>
<p>header 是 token 的一部分，用来存放 token 的类型和编码方式，通常是使用 base-64 编码。</p>
<p>payload 包含了信息。你可以存放任一种信息，比如用户信息，产品信息等。它们都是使用 base-64 编码方式进行存储。<br>signature 包括了 header，payload 和密钥的混合体。密钥必须安全地保存储在服务端。</p>
<p><img src="/img/2015-06-14/2.jpg" alt=""></p>
<p>nodejs实现的jwt代码</p>
<p><a href="http://github.com/auth0/node-jsonwebtoken" target="_blank" rel="external">http://github.com/auth0/node-jsonwebtoken</a></p>
<p>主要3个方法</p>
<ul>
<li>jwt.sign</li>
<li>jwt.verify</li>
<li>jwt.decode</li>
</ul>
<p>需要小心的密钥在多线程或集群下的处理。</p>
<p>加解密一个对象的时间，远远比查询数据库的代价小，唯一可能有的是token有效期的校验，代价极其小。</p>
<h2 id="优雅之写法">优雅之写法</h2><h3 id="授权获取token">授权获取token</h3><p>在app/routes/api/index.js里</p>
<pre><code><span class="comment">// auth</span>
router.post(<span class="string">'/auth'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>{
  User.one({username: req.body.username},<span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>)</span>{
    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
    <span class="built_in">console</span>.log(user);

    <span class="keyword">if</span> (!user) {
        res.json({ success: <span class="literal">false</span>, message: <span class="string">'认证失败，用户名找不到'</span> });
    } <span class="keyword">else</span> <span class="keyword">if</span> (user) {

      <span class="comment">// 检查密码</span>
      <span class="keyword">if</span> (user.password != req.body.password) {
          res.json({ success: <span class="literal">false</span>, message: <span class="string">'认证失败，密码错误'</span> });
      } <span class="keyword">else</span> {
        <span class="comment">// 创建token</span>
        <span class="keyword">var</span> token = jwt.sign(user, <span class="string">'app.get(superSecret)'</span>, {
            <span class="string">'expiresInMinutes'</span>: <span class="number">1440</span> <span class="comment">// 设置过期时间</span>
        });

        <span class="comment">// json格式返回token</span>
        res.json({
            success: <span class="literal">true</span>,
            message: <span class="string">'Enjoy your token!'</span>,
            token: token
        });
      }
    }
  });
});
</code></pre><ul>
<li>post请求</li>
<li>地址<a href="http://127.0.0.1:3019/api/auth" target="_blank" rel="external">http://127.0.0.1:3019/api/auth</a></li>
<li>参数”username=sang&amp;password=000000”</li>
</ul>
<p>测试</p>
<pre><code>curl -d <span class="string">"username=sang&amp;password=000000"</span> <span class="string">http:</span><span class="comment">//127.0.0.1:3019/api/auth</span>
</code></pre><p>返回</p>
<pre><code>{<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"message"</span>:<span class="string">"Enjoy your token!"</span>,<span class="string">"token"</span>:<span class="string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJfaWQiOiI1NTc4MzJkZjk0ZTFjN2YyMDJmYTVlNGUiLCJ1c2VybmFtZSI6InNhbmciLCJwYXNzd29yZCI6IjAwMDAwMCIsImF2YXRhciI6IiIsInBob25lX251bWJlciI6IiIsImFkZHJlc3MiOiIiLCJfX3YiOjB9.Wv5za6GpJSMi346o625_8FxfoM4dJ1cWNuezG10zQG4"</span>}%
</code></pre><h3 id="路由处理">路由处理</h3><p>在<code>app/routes/api/groups.js</code>里</p>
<pre><code><span class="built_in">var</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>);
<span class="built_in">var</span> router = express<span class="built_in">.</span>Router();

<span class="built_in">var</span> $ = <span class="keyword">require</span>(<span class="string">'../../controllers/groups_controller'</span>);
<span class="built_in">var</span> <span class="variable">$middlewares</span> = <span class="keyword">require</span>(<span class="string">'mount-middlewares'</span>);

router<span class="built_in">.</span>get(<span class="string">'/list'</span>, <span class="variable">$middlewares.check_api_token</span>, $<span class="built_in">.</span>api<span class="built_in">.</span><span class="built_in">list</span>);

module<span class="built_in">.</span>exports = router;
</code></pre><p>核心代码</p>
<pre><code>router.get(<span class="string">'/list'</span>, <span class="variable">$middlewares</span>.check_api_token, $.api.list);
</code></pre><p>说明</p>
<ul>
<li>使用了$middlewares.check_api_token中间件</li>
<li>核心业务逻辑在$.api.list</li>
<li>和其他的express路由用法一样，无他</li>
</ul>
<h3 id="中间件$middlewares-check_api_token">中间件$middlewares.check_api_token</h3><pre><code><span class="comment">/*!
 * Moajs Middle
 * Copyright(c) 2015-2019 Alfred Sang &lt;shiren1118@126.com&gt;
 * MIT Licensed
 */</span>

<span class="keyword">var</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);<span class="comment">//用来创建和确认用户信息摘要</span>
<span class="comment">// 检查用户会话</span>
<span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'检查post的信息或者url查询参数或者头信息'</span>);
  <span class="comment">//检查post的信息或者url查询参数或者头信息</span>
  <span class="keyword">var</span> token = req.body.token || req.query.token || req.headers[<span class="string">'x-access-token'</span>];
  <span class="comment">// 解析 token</span>
  <span class="keyword">if</span> (token) {
    <span class="comment">// 确认token</span>
    jwt.verify(token, <span class="string">'app.get(superSecret)'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, decoded</span>) </span>{
      <span class="keyword">if</span> (err) {
        <span class="keyword">return</span> res.json({ success: <span class="literal">false</span>, message: <span class="string">'token信息错误.'</span> });
      } <span class="keyword">else</span> {
        <span class="comment">// 如果没问题就把解码后的信息保存到请求中，供后面的路由使用</span>
        req.api_user = decoded;
        <span class="built_in">console</span>.dir(req.api_user);
        next();
      }
    });
  } <span class="keyword">else</span> {
    <span class="comment">// 如果没有token，则返回错误</span>
    <span class="keyword">return</span> res.status(<span class="number">403</span>).send({
        success: <span class="literal">false</span>,
        message: <span class="string">'没有提供token！'</span>
    });
  }
};
</code></pre><p>这个很容易解释，只要参数有token或者头信息里有x-access-token，我们就认定它是一个api接口，</p>
<p>校验通过了，就把token的decode对象，也就是之前加密的用户对象返回来，保存为<code>req.api_user</code></p>
<h3 id="业务代码">业务代码</h3><p>在<code>app/controllers/groups_controller.js</code>里</p>
<pre><code>exports.api = {
  list: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
    <span class="built_in">console</span>.log(req.method + <span class="string">' /groups =&gt; list, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query));

    <span class="keyword">var</span> user_id = req.api_user._id;

    Group.query({ower_id: user_id}, <span class="function"><span class="keyword">function</span>(<span class="params">err, groups</span>)</span>{
      <span class="built_in">console</span>.log(groups);
      res.json({
        data:{
          groups : groups
        },
        status:{
          code  : <span class="number">0</span>,
          msg   : <span class="string">'success'</span>
        }
      })
    });
  }
}
</code></pre><p>让scaffold生成代码和api共存，清晰明了</p>
<p>说明一下</p>
<ul>
<li>req.api_user是$middlewares.check_api_token里赋值的</li>
<li>写一个下查询接口，返回json即可</li>
</ul>
<h3 id="测试接口">测试接口</h3><p>然后让我们来测试一下</p>
<ul>
<li>get请求</li>
<li>url = <a href="http://127.0.0.1:3019/api/groups/list" target="_blank" rel="external">http://127.0.0.1:3019/api/groups/list</a></li>
<li>参数token</li>
</ul>
<pre><code>curl http://<span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">3019</span>/api/groups/list\?token\=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJfaWQiOiI1NTc4MzJkZjk0ZTFjN2YyMDJmYTVlNGUiLCJ1c2VybmFtZSI6InNhbmciLCJwYXNzd29yZCI6IjAwMDAwMCIsImF2YXRhciI6IiIsInBob25lX251bWJlciI6IiIsImFkZHJlc3MiOiIiLCJfX3YiOjB9.Wv5za6GpJSMi346o625_8FxfoM4dJ1cWNuezG10zQG4


  {<span class="string">"data"</span>:{<span class="string">"groups"</span>:[{<span class="string">"_id"</span>:<span class="string">"557d32a282f9ddcc76a540e8"</span>,<span class="string">"name"</span>:<span class="string">"sjkljkl"</span>,<span class="string">"desc"</span>:<span class="string">"2323"</span>,<span class="string">"ower_id"</span>:<span class="string">"557832df94e1c7f202fa5e4e"</span>,<span class="string">"users"</span>:<span class="string">""</span>,<span class="string">"is_public"</span>:<span class="string">""</span>,<span class="string">"__v"</span>:<span class="number">0</span>},{<span class="string">"_id"</span>:<span class="string">"557d32b082f9ddcc76a540e9"</span>,<span class="string">"name"</span>:<span class="string">"sjkljkl"</span>,<span class="string">"desc"</span>:<span class="string">"2323"</span>,<span class="string">"ower_id"</span>:<span class="string">"557832df94e1c7f202fa5e4e"</span>,<span class="string">"users"</span>:<span class="string">""</span>,<span class="string">"is_public"</span>:<span class="string">""</span>,<span class="string">"__v"</span>:<span class="number">0</span>},{<span class="string">"_id"</span>:<span class="string">"557d32f082f9ddcc76a540ea"</span>,<span class="string">"name"</span>:<span class="string">"sjkljkl"</span>,<span class="string">"desc"</span>:<span class="string">"2323"</span>,<span class="string">"ower_id"</span>:<span class="string">"557832df94e1c7f202fa5e4e"</span>,<span class="string">"users"</span>:<span class="string">""</span>,<span class="string">"is_public"</span>:<span class="string">""</span>,<span class="string">"__v"</span>:<span class="number">0</span>},{<span class="string">"_id"</span>:<span class="string">"557d33804f5905de78e1c25a"</span>,<span class="string">"name"</span>:<span class="string">"sjkljkl"</span>,<span class="string">"desc"</span>:<span class="string">"2323"</span>,<span class="string">"ower_id"</span>:<span class="string">"557832df94e1c7f202fa5e4e"</span>,<span class="string">"users"</span>:<span class="string">""</span>,<span class="string">"is_public"</span>:<span class="string">""</span>,<span class="string">"__v"</span>:<span class="number">0</span>},{<span class="string">"_id"</span>:<span class="string">"557d33984f5905de78e1c25b"</span>,<span class="string">"name"</span>:<span class="string">"anan"</span>,<span class="string">"desc"</span>:<span class="string">"2323"</span>,<span class="string">"ower_id"</span>:<span class="string">"557832df94e1c7f202fa5e4e"</span>,<span class="string">"users"</span>:<span class="string">"2323"</span>,<span class="string">"is_public"</span>:<span class="string">"232"</span>,<span class="string">"__v"</span>:<span class="number">0</span>}]},<span class="string">"status"</span>:{<span class="string">"code"</span>:<span class="number">0</span>,<span class="string">"msg"</span>:<span class="string">"success"</span>}}  
</code></pre><h3 id="模型，查询以及其他">模型，查询以及其他</h3><p>模型，查询以及其他，沿用之前的东西，仍然以mongoosedao为主</p>
<ul>
<li>one</li>
<li>all</li>
<li>query</li>
</ul>
<p>基本上够用了</p>
<p>如果还想玩的更high一点，可以增加一个service层，把多个model的操作放到里面。</p>
<h2 id="总结">总结</h2><p>以后写api，可以这样玩</p>
<p>1) 在<code>app/routes/api/</code>目录下建立对应的api文件，比如groups.js，topics.js，users.js等</p>
<p>2) 然后在对应的controller里，增加</p>
<pre><code>exports.api = {
  aa:<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span>{
    <span class="keyword">var</span> user_id = req.api_user._id;
  },
  bb:<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span>{
    <span class="keyword">var</span> user_id = req.api_user._id;
  }
}
</code></pre><p>3) 简单写点模型的查询方法就可以了</p>
<p>是不是很简单？</p>
<ul>
<li>使用mount-routes自动挂载routes</li>
<li>使用mongoosedao更简单的接口</li>
</ul>
<p>如果以后再提供生成器呢？</p>
<p>想想就很美好，美好就继续美好吧~</p>
<p>补一下</p>
<ul>
<li>Nodejs RESTFul架构实践 <a href="http://nodeonly.com/2015/06/09/expressjs-rest.html" target="_blank" rel="external">http://nodeonly.com/2015/06/09/expressjs-rest.html</a></li>
</ul>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/14/node-restful-api/" data-id="cid190g3z000gam7fcpy3puii" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pm2-issue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/13/pm2-issue/" class="article-date">
  <time datetime="2015-06-12T16:00:00.000Z" itemprop="datePublished">2015-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/13/pm2-issue/">Nodejs部署再思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="pm2">pm2</h2><p>好处就不说了</p>
<p>今天遇到一个奇怪的问题，部署一台新的机器，无论怎么弄，什么版本都会报错</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js-bson: Failed <span class="built_in">to</span> <span class="built_in">load</span> c++ bson extension, <span class="keyword">using</span> pure JS <span class="built_in">version</span></span><br></pre></td></tr></table></figure>
<p>我曾经无数次的怀疑，是mongodb的问题，于是我手动编译了bson和bson-ext，以及相关的</p>
<ul>
<li>connect-mongo</li>
<li>mongoose</li>
</ul>
<p>可是还不好使。。。。。</p>
<p>我觉得很奇怪，没有理由啊，我去查pm2的源码和文档，发现cluster mode必须是0.12之后才有，之前的方式都是fork模式的。</p>
<p>最后发现 <a href="https://github.com/Unitech/PM2/issues/957" target="_blank" rel="external">https://github.com/Unitech/PM2/issues/957</a></p>
<p>@jorge-d commented on Mar 11</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I just tested <span class="operator">with</span> node v0<span class="number">.12</span><span class="number">.0</span> <span class="operator">and</span> pm2 <span class="number">0.12</span><span class="number">.7</span> <span class="operator">and</span> everything seems <span class="built_in">to</span> be working fine...</span><br><span class="line">Could you <span class="built_in">do</span> <span class="operator">a</span> simple test ? run pm2 <span class="built_in">kill</span>; pm2 <span class="built_in">start</span> app.js -i <span class="number">0</span> <span class="operator">and</span> tell me whether <span class="keyword">it</span> starts <span class="operator">in</span> cluster <span class="operator">of</span> fork mode ?</span><br></pre></td></tr></table></figure>
<p>然后那货的问题就解决了，然后我试了一下</p>
<pre><code>pm2 <span class="built_in">kill</span>
</code></pre><p>是杀死pm2自己的进程，然后产生新的，相当于重启。</p>
<p>然后再跑就可以了</p>
<h2 id="反思一下，为什么会出现这样的问题？">反思一下，为什么会出现这样的问题？</h2><p>node的版本较多</p>
<ul>
<li>nodejs（0.10 和0.12 集群模块不一样，还有就是对es6的支持）</li>
<li>iojs（目前以及2.3+）</li>
</ul>
<p>我最开始部署的时候用的是iojs最新版本，然后我启动过<code>pm2</code>,克隆完源码之后，<code>npm install</code>的时候有模块无法编译，所以我就切换0.10了</p>
<p>哎，我没有想到pm2会一直存在，只要不kill就在，而且我不喜欢动不动就重启服务器，所以花了几个小时的时间才解决。</p>
<h2 id="pm2_deploy">pm2 deploy</h2><p>ruby 里有 capistrano 部署</p>
<ul>
<li><a href="http://capistranorb.com/" target="_blank" rel="external">http://capistranorb.com/</a></li>
</ul>
<p>node世界里也有shipit</p>
<ul>
<li><a href="https://github.com/shipitjs/shipit" target="_blank" rel="external">https://github.com/shipitjs/shipit</a></li>
</ul>
<p>说白点都是“Universal automation and deployment tool”，通用自动化部署工具而已。</p>
<p>实际上Unitech也打算给pm2增加这样的功能，让pm2成为一个全能的货</p>
<ul>
<li>代码： <a href="https://github.com/Unitech/pm2-deploy" target="_blank" rel="external">https://github.com/Unitech/pm2-deploy</a></li>
<li>文档：<a href="https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment-help" target="_blank" rel="external">https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment-help</a></li>
</ul>
<p>它完成了几件事儿</p>
<ul>
<li>evn环境变量</li>
<li>ssh远程key配置</li>
<li>git代码以及分支切换</li>
<li>各种回调钩子，比如post-deploy</li>
</ul>
<p>以上特性足矣和任何ci或者其他自动化工具集成了，目前可以当小白鼠的。</p>
<h2 id="部署相关，小弟们必看">部署相关，小弟们必看</h2><p>部署的基本常识</p>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-pm2-to-setup-a-node-js-production-environment-on-an-ubuntu-vps" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-use-pm2-to-setup-a-node-js-production-environment-on-an-ubuntu-vps</a></li>
</ul>
<p>NGINX+PM2组合</p>
<ul>
<li><a href="https://doesnotscale.com/deploying-node-js-with-pm2-and-nginx/" target="_blank" rel="external">https://doesnotscale.com/deploying-node-js-with-pm2-and-nginx/</a></li>
</ul>
<p>注意配置</p>
<pre><code>server {  
  server_name your.domain.com;
  listen <span class="number">80</span>;

  location / {
    proxy_set_header X-Real-IP <span class="variable">$remote</span>_addr;
    proxy_set_header X-Forwarded-For <span class="variable">$proxy</span>_add_x_forwarded_for;
    proxy_set_header Host <span class="variable">$http</span>_host;
    proxy_set_header X-NginX-Proxy true;
    proxy_pass http://<span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">3000</span>;
    proxy_redirect off;
  }
}
</code></pre><p>图片处理<a href="https://serversforhackers.com/nginx-caching" target="_blank" rel="external">https://serversforhackers.com/nginx-caching</a></p>
<pre><code>location ~<span class="keyword">*</span> \.(js|<span class="string">css</span>|<span class="string">png</span>|<span class="string">jpg</span>|<span class="string">jpeg</span>|<span class="string">gif</span>|<span class="string">ico)$ {
    expires 1y;
    log_not_found off;
}</span>
</code></pre><p>如果有兴趣，也可以看一下我写的node部署</p>
<p><a href="http://nodeonly.com/2015/06/02/deploy.html" target="_blank" rel="external">http://nodeonly.com/2015/06/02/deploy.html</a></p>
<p>sudo systemctl enable nginx.service<br>sudo systemctl enable redis.service<br>sudo chkconfig mongod on</p>
<p>nohup node /home/deploy/workspace/oschina/mxb-sms/app.js &gt; /home/deploy/workspace/oschina/mxb-sms/sms.log 2&gt;&amp;1 &amp;</p>
<h2 id="这样的部署真的足够了么？">这样的部署真的足够了么？</h2><p>一台一台机器的部署也是醉了。。。。哥是程序员啊</p>
<p>复用和弹性伸缩才是真爱</p>
<p>所以比较好的方式是使用docker来处理，docker是lxc，里面可以部署任意linux系统<br>配置各种环境，完成任意弹性扩容</p>
<p>目前nearfarm已经有一个不错的实现</p>
<p><a href="https://github.com/nearform/nscale" target="_blank" rel="external">https://github.com/nearform/nscale</a></p>
<p>具体原理以及相关实践，稍后整理</p>
<p>全文完</p>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/13/pm2-issue/" data-id="cid190g40000ham7f60dvo7nc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-expressjs-rest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/10/expressjs-rest/" class="article-date">
  <time datetime="2015-06-09T16:00:00.000Z" itemprop="datePublished">2015-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/10/expressjs-rest/">监控Nodejs的页面响应时间</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="监控Nodejs的页面响应时间">监控Nodejs的页面响应时间</h2><p>最近想监控一下Nodejs的性能。记录分析Log太麻烦，最简单的方式是记录每个HTTP请求的处理时间，直接在HTTP Response Header中返回。</p>
<p>记录HTTP请求的时间很简单，就是收到请求记一个时间戳，响应请求的时候再记一个时间戳，两个时间戳之差就是处理时间。</p>
<p>但是，res.send()代码遍布各个js文件，总不能把每个URL处理函数都改一遍吧。</p>
<p>正确的思路是用middleware实现。但是Nodejs没有任何拦截res.send()的方法，怎么破？</p>
<p>其实只要稍微转换一下思路，放弃传统的OOP方式，以函数对象看待res.send()，我们就可以先保存原始的处理函数res.send，再用自己的处理函数替换res.send：</p>
<pre><code>app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
    <span class="comment">// 记录start time:</span>
    <span class="keyword">var</span> exec_start_at = <span class="built_in">Date</span>.now();
    <span class="comment">// 保存原始处理函数:</span>
    <span class="keyword">var</span> _send = res.send;
    <span class="comment">// 绑定我们自己的处理函数:</span>
    res.send = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="comment">// 发送Header:</span>
        res.set(<span class="string">'X-Execution-Time'</span>, <span class="built_in">String</span>(<span class="built_in">Date</span>.now() - exec_start_at));
        <span class="comment">// 调用原始处理函数:</span>
        <span class="keyword">return</span> _send.apply(res, <span class="built_in">arguments</span>);
    };
    next();
});
</code></pre><p>只用了几行代码，就把时间戳搞定了。</p>
<p>对于res.render()方法不需要处理，因为res.render()内部调用了res.send()。</p>
<p>调用apply()函数时，传入res对象很重要，否则原始的处理函数的this指向undefined直接导致出错。</p>
<p>实测首页响应时间9毫秒：</p>
<p><img src="/css/2015-06-10/1.png" alt=""></p>
<p>原作者廖雪峰<br>原文链接 <a href="http://www.liaoxuefeng.com/article/0014007460517001bbb3e2f624a4917b742635e9a6b15dd000" target="_blank" rel="external">http://www.liaoxuefeng.com/article/0014007460517001bbb3e2f624a4917b742635e9a6b15dd000</a></p>
<h3 id="点评">点评</h3><ul>
<li>以中间价来处理是复用最大的方法，全局中间价是每一个http请求都要经过的</li>
<li>通过apply给res对象增加header，只要出发res.send就会带上header是很巧妙的做法</li>
<li>res.send是所有res的最底层方法，其他方法也会调用，比如res.json也会调用send</li>
</ul>
<h2 id="send源码">send源码</h2><p>这是express里res.send方法的源码</p>
<pre><code><span class="comment">/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(new Buffer('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('&lt;p&gt;some html&lt;/p&gt;');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @api public
 */</span>

res.send = <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(body)</span> </span>{
  <span class="keyword">var</span> chunk = body;
  <span class="keyword">var</span> encoding;
  <span class="keyword">var</span> len;
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> type;

  <span class="comment">// settings</span>
  <span class="keyword">var</span> app = <span class="keyword">this</span>.app;

  <span class="comment">// allow status / body</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="comment">// res.send(body, status) backwards compat</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] !== <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> arguments[<span class="number">1</span>] === <span class="string">'number'</span>) {
      deprecate(<span class="string">'res.send(body, status): Use res.status(status).send(body) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">1</span>];
    } <span class="keyword">else</span> {
      deprecate(<span class="string">'res.send(status, body): Use res.status(status).send(body) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">0</span>];
      chunk = arguments[<span class="number">1</span>];
    }
  }

  <span class="comment">// disambiguate res.send(status) and res.send(status, num)</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'number'</span> &amp;&amp; arguments.length === <span class="number">1</span>) {
    <span class="comment">// res.send(status) will set status message as text string</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'Content-Type'</span>)) {
      <span class="keyword">this</span>.type(<span class="string">'txt'</span>);
    }

    deprecate(<span class="string">'res.send(status): Use res.sendStatus(status) instead'</span>);
    <span class="keyword">this</span>.statusCode = chunk;
    chunk = http.STATUS_CODES[chunk];
  }

  <span class="keyword">switch</span> (<span class="keyword">typeof</span> chunk) {
    <span class="comment">// string defaulting to html</span>
    <span class="keyword">case</span> <span class="string">'string'</span>:
      <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'Content-Type'</span>)) {
        <span class="keyword">this</span>.type(<span class="string">'html'</span>);
      }
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'boolean'</span>:
    <span class="keyword">case</span> <span class="string">'number'</span>:
    <span class="keyword">case</span> <span class="string">'object'</span>:
      <span class="keyword">if</span> (chunk === <span class="literal">null</span>) {
        chunk = <span class="string">''</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (Buffer.isBuffer(chunk)) {
        <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'Content-Type'</span>)) {
          <span class="keyword">this</span>.type(<span class="string">'bin'</span>);
        }
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.json(chunk);
      }
      <span class="keyword">break</span>;
  }

  <span class="comment">// write strings in utf-8</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'string'</span>) {
    encoding = <span class="string">'utf8'</span>;
    type = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'Content-Type'</span>);

    <span class="comment">// reflect this in content-type</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) {
      <span class="keyword">this</span>.<span class="keyword">set</span>(<span class="string">'Content-Type'</span>, setCharset(type, <span class="string">'utf-8'</span>));
    }
  }

  <span class="comment">// populate Content-Length</span>
  <span class="keyword">if</span> (chunk !== <span class="literal">undefined</span>) {
    <span class="keyword">if</span> (!Buffer.isBuffer(chunk)) {
      <span class="comment">// convert chunk to Buffer; saves later double conversions</span>
      chunk = <span class="keyword">new</span> Buffer(chunk, encoding);
      encoding = <span class="literal">undefined</span>;
    }

    len = chunk.length;
    <span class="keyword">this</span>.<span class="keyword">set</span>(<span class="string">'Content-Length'</span>, len);
  }

  <span class="comment">// populate ETag</span>
  <span class="keyword">var</span> etag;
  <span class="keyword">var</span> generateETag = len !== <span class="literal">undefined</span> &amp;&amp; app.<span class="keyword">get</span>(<span class="string">'etag fn'</span>);
  <span class="keyword">if</span> (<span class="keyword">typeof</span> generateETag === <span class="string">'function'</span> &amp;&amp; !<span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'ETag'</span>)) {
    <span class="keyword">if</span> ((etag = generateETag(chunk, encoding))) {
      <span class="keyword">this</span>.<span class="keyword">set</span>(<span class="string">'ETag'</span>, etag);
    }
  }

  <span class="comment">// freshness</span>
  <span class="keyword">if</span> (req.fresh) <span class="keyword">this</span>.statusCode = <span class="number">304</span>;

  <span class="comment">// strip irrelevant headers</span>
  <span class="keyword">if</span> (<span class="number">204</span> == <span class="keyword">this</span>.statusCode || <span class="number">304</span> == <span class="keyword">this</span>.statusCode) {
    <span class="keyword">this</span>.removeHeader(<span class="string">'Content-Type'</span>);
    <span class="keyword">this</span>.removeHeader(<span class="string">'Content-Length'</span>);
    <span class="keyword">this</span>.removeHeader(<span class="string">'Transfer-Encoding'</span>);
    chunk = <span class="string">''</span>;
  }

  <span class="keyword">if</span> (req.method === <span class="string">'HEAD'</span>) {
    <span class="comment">// skip body for HEAD</span>
    <span class="keyword">this</span>.end();
  } <span class="keyword">else</span> {
    <span class="comment">// respond</span>
    <span class="keyword">this</span>.end(chunk, encoding);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</code></pre><p>没啥难点</p>
<pre><code>res.json = <span class="function"><span class="keyword">function</span> <span class="title">json</span>(<span class="params">obj</span>) </span>{
  <span class="keyword">var</span> val = obj;

  <span class="comment">// allow status / body</span>
  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) {
    <span class="comment">// res.json(body, status) backwards compat</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">1</span>] === <span class="string">'number'</span>) {
      deprecate(<span class="string">'res.json(obj, status): Use res.status(status).json(obj) instead'</span>);
      <span class="keyword">this</span>.statusCode = <span class="built_in">arguments</span>[<span class="number">1</span>];
    } <span class="keyword">else</span> {
      deprecate(<span class="string">'res.json(status, obj): Use res.status(status).json(obj) instead'</span>);
      <span class="keyword">this</span>.statusCode = <span class="built_in">arguments</span>[<span class="number">0</span>];
      val = <span class="built_in">arguments</span>[<span class="number">1</span>];
    }
  }

  <span class="comment">// settings</span>
  <span class="keyword">var</span> app = <span class="keyword">this</span>.app;
  <span class="keyword">var</span> replacer = app.get(<span class="string">'json replacer'</span>);
  <span class="keyword">var</span> spaces = app.get(<span class="string">'json spaces'</span>);
  <span class="keyword">var</span> body = <span class="built_in">JSON</span>.stringify(val, replacer, spaces);

  <span class="comment">// content-type</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>)) {
    <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>.send(body);
};
</code></pre><p>这里的的最后一行<code>return this.send(body)</code>,它实际上就上面的res.send方法</p>
<p>其他方法也一样</p>
<ul>
<li>jsonp</li>
<li>render</li>
</ul>
<h2 id="自己要用，于是copy了一份">自己要用，于是copy了一份</h2><p>request-time</p>
<p>Install</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> <span class="comment">--save request-time</span></span>
</code></pre><p>Usages</p>
<pre><code><span class="keyword">var</span> express       = <span class="keyword">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> request-time  = <span class="keyword">require</span>(<span class="string">'request-time'</span>);

<span class="keyword">var</span> app = <span class="keyword">new</span> express();
app.<span class="keyword">use</span>(request-time);
</code></pre><p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/10/expressjs-rest/" data-id="cid190g42000iam7fziszqu71" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-expressjs-rest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/09/expressjs-rest/" class="article-date">
  <time datetime="2015-06-08T16:00:00.000Z" itemprop="datePublished">2015-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/09/expressjs-rest/">Nodejs RESTFul架构实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="准备">准备</h2><p>如果你不了解http协议，先看一下<a href="https://github.com/i5ting/node-http" target="_blank" rel="external">https://github.com/i5ting/node-http</a></p>
<h2 id="什么是REST？">什么是REST？</h2><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>以下内容摘自阮一峰的文章：</p>
<p>一、起源</p>
<p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p>
<p>二、名称</p>
<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。<br>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>三、资源（Resources）</p>
<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>四、表现层（Representation）</p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>五、状态转化（State Transfer）</p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>六、综述</p>
<p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p><strong>说的通俗一点，改变url写法，让它带有状态，即语义化</strong></p>
<p>更多详见：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li>
<li><a href="http://www.restapitutorial.com/lessons/whatisrest.html" target="_blank" rel="external">http://www.restapitutorial.com/lessons/whatisrest.html</a></li>
</ul>
<h2 id="请求方法">请求方法</h2><p>一般会严格要求请求方法及其释义，下面给出常用的请求方法</p>
<ul>
<li>如果请求头中存在 <code>X-HTTP-Method-Override</code> 或参数中存在 <code>_method</code>（拥有更高权重），且值为 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>, <code>OPTION</code>, <code>HEAD</code> 之一，则视作相应的请求方式进行处理</li>
<li><code>GET</code>, <code>DELETE</code>, <code>HEAD</code> 方法，参数风格为标准的 <code>GET</code> 风格的参数，如 <code>url?a=1&amp;b=2</code></li>
<li><code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>OPTION</code> 方法<ul>
<li>默认情况下请求实体会被视作标准 json 字符串进行处理，当然，依旧推荐设置头信息的 <code>Content-Type</code> 为 <code>application/json</code></li>
<li>在一些特殊接口中（会在文档中说明），可能允许 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 或者 <code>multipart/form-data</code> ，此时请求实体会被视作标准 <code>POST</code> 风格的参数进行处理</li>
</ul>
</li>
</ul>
<p>关于方法语义的说明：</p>
<ul>
<li><code>OPTIONS</code> 用于获取资源支持的所有 HTTP 方法</li>
<li><code>HEAD</code> 用于只获取请求某个资源返回的头信息</li>
<li><code>GET</code> 用于从服务器获取某个资源的信息<ul>
<li>完成请求后返回状态码 <code>200 OK</code></li>
<li>完成请求后需要返回被请求的资源详细信息</li>
</ul>
</li>
<li><code>POST</code> 用于创建新资源<ul>
<li>创建完成后返回状态码 <code>201 Created</code></li>
<li>完成请求后需要返回被创建的资源详细信息</li>
</ul>
</li>
<li><code>PUT</code> 用于完整的替换资源或者创建指定身份的资源，比如创建 id 为 123 的某个资源<ul>
<li>如果是创建了资源，则返回 <code>201 Created</code></li>
<li>如果是替换了资源，则返回 <code>200 OK</code></li>
<li>完成请求后需要返回被修改的资源详细信息</li>
</ul>
</li>
<li><code>PATCH</code> 用于局部更新资源<ul>
<li>完成请求后返回状态码 <code>200 OK</code></li>
<li>完成请求后需要返回被修改的资源详细信息</li>
</ul>
</li>
<li><code>DELETE</code> 用于删除某个资源<ul>
<li>完成请求后返回状态码 <code>204 No Content</code></li>
</ul>
</li>
</ul>
<p>上面是比较常见的，估计大部分人最常用的是2个，get和post，具体每个怎么玩，下面会给出实例</p>
<h2 id="最常见的增删改查">最常见的增删改查</h2><p>以前大家都认为管理信息系统就是crud，认为没有啥技术含量，哎，真正能把crud写明白其实也不是一件容易的事儿</p>
<p>七个路由，见<code>app/routes/users.js</code></p>
<p>其中4个路由是crud</p>
<ul>
<li>GET    /users[/]        =&gt; user.list()</li>
<li>POST   /users[/]        =&gt; user.create()</li>
<li>PATCH  /users/:id       =&gt; user.update()</li>
<li>DELETE /users/:id       =&gt; user.destroy()</li>
</ul>
<p>另外3个是页面渲染用的</p>
<ul>
<li>GET    /users/new       =&gt; user.new()</li>
<li>GET    /users/:id       =&gt; user.show()</li>
<li>GET    /users/:id/edit  =&gt; user.edit()</li>
</ul>
<p>那么我们先来看一下crud对应的请求方法</p>
<ul>
<li>get用于请求列表</li>
<li>post用于创建</li>
<li>patch用于更新，局部更新资源</li>
<li>delete用于删除</li>
</ul>
<p>对比上一节的内容，你会发现他们的含义貌似真的对了，唯一可能有争议是更新，有的人用put有的用patch，推荐patch</p>
<p>以前做java的时候会认为，创建、删除和更新都用post，查询和搜索用get，这样做没问题，只是不符合rest风格而已。</p>
<p>很多人和我讨论过到该不该rest，我的回答是</p>
<ul>
<li><a href="https://cnodejs.org/topic/552b3b9382388cec50cf6d95" target="_blank" rel="external">客户端 API 开发总结</a></li>
</ul>
<h2 id="express代码分层">express代码分层</h2><p>默认的express生成器生成的只有routes和views文件夹，相对比较简单，做大型应用怎么能少了mvc呢？</p>
<p>于是我仿照rails写了如下代码分层</p>
<ul>
<li>routes 路由层，只有url和中间件，不包含任何逻辑</li>
<li>controllers 业务逻辑控制层</li>
<li>models  模型层</li>
<li>views  视图层</li>
</ul>
<p>如下图</p>
<p><img src="/img/2015-06-09/1.png" alt=""></p>
<h2 id="路由层">路由层</h2><p>上代码</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> router = express.Router();

<span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'../controllers/users_controller'</span>);


<span class="comment">// -- custom</span>


<span class="comment">/**
 * Auto generate RESTful url routes.
 *
 * URL routes:
 *
 *  GET    /users[/]        =&gt; user.list()
 *  GET    /users/new       =&gt; user.new()
 *  GET    /users/:id       =&gt; user.show()
 *  GET    /users/:id/edit  =&gt; user.edit()
 *  POST   /users[/]        =&gt; user.create()
 *  PATCH  /users/:id       =&gt; user.update()
 *  DELETE /users/:id       =&gt; user.destroy()
 *
 */</span>

router.get(<span class="string">'/new'</span>, $.<span class="keyword">new</span>);  
router.get(<span class="string">'/:id/edit'</span>, $.edit);

router.route(<span class="string">'/'</span>)
  .get($.list)
  .post($.create);

router.route(<span class="string">'/:id'</span>)
  .patch($.update)
  .get($.show)
  .delete($.destroy);


<span class="built_in">module</span>.exports = router;
</code></pre><p>和普通的路由代码一样，稍微改造了一下，统一了地址，应该是更清晰了。</p>
<p>这里只是引入了<code>users_controller</code>文件，完成请求地址和业务处理代码的映射而已。</p>
<p>这里还要讨论一个问题，每次增加一个接口就要加一个路由会比较烦，而且要在app.js里配置，能不能自动加载呢？比如app/routes目录下的所有js都可以挂载到app上</p>
<p>答案是可以的，使用我写的<code>mount-routes</code>即可，示例如下：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)
<span class="keyword">var</span> app = express()

<span class="keyword">var</span> mount = <span class="built_in">require</span>(<span class="string">'mount-routes'</span>);

<span class="comment">// 简单用法，加载app/routes下的所有路由</span>
<span class="comment">// mount(app);</span>

<span class="comment">// 带路径的用法，加载routes2目录下的所有路由</span>
<span class="comment">// mount(app, 'routes2');</span>

<span class="comment">// 带路径的用法并且可以打印出路有表</span>
mount(app, <span class="string">'routes2'</span>, <span class="literal">true</span>);

<span class="comment">// start server</span>
app.listen(<span class="number">23018</span>)
</code></pre><p>更多内容见</p>
<p><a href="https://cnodejs.org/topic/556bd8ecf6ec9c0f020377c2" target="_blank" rel="external">mount-routes</a></p>
<h2 id="控制层">控制层</h2><pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Created by sang on 01/06/14.
 <span class="keyword">*</span>/

var User = require('../models/user');
</code></pre><p>首先，控制层是控制业务处理的，所以它和模型层打交道比较多，同时控制视图如何展示</p>
<pre><code>exports.list = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users =&gt; list, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query));
  User.getAll(<span class="function"><span class="keyword">function</span>(<span class="params">err, users</span>)</span>{
    <span class="built_in">console</span>.log(users);
    res.render(<span class="string">'users/index'</span>, {
      users : users
    })
  });
};
</code></pre><p>请求所有列表，很简单，获取所有用户即可</p>
<pre><code>exports.new = function (req, res, next) {
  console.log(req.<span class="keyword">method</span> + ' /users/new =&gt; new, query: ' + <span class="type">JSON</span>.stringify(req.query));

  res.render('users/new', {
    user : {
      <span class="string">"_action"</span> : <span class="string">"new"</span>
    }
  })
};
</code></pre><p>新建用户，实际是render视图而已，没有啥逻辑，user参数是为了我生成代码方便用的，无他</p>
<pre><code>exports.show = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id =&gt; show, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params));
  <span class="keyword">var</span> id = req.params.id;

  User.getById(id, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
    <span class="built_in">console</span>.log(user);
    res.render(<span class="string">'users/show'</span>, {
      user : user
    })
  });
};
</code></pre><p>同new，是render视图代码</p>
<pre><code>exports.edit = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id/edit =&gt; edit, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params));

  <span class="keyword">var</span> id = req.params.id; 

  User.getById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
    <span class="built_in">console</span>.log(user);
    user._action = <span class="string">'edit'</span>;

    res.render(<span class="string">'users/edit'</span>, {
      user : user
    })
  });
};
</code></pre><p>同new，是render视图代码</p>
<pre><code>exports.create = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users =&gt; create, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params) + <span class="string">', body: '</span> + <span class="built_in">JSON</span>.stringify(req.body));

    User.create({name: req.body.name,password: req.body.password}, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="built_in">console</span>.log(user);
      res.render(<span class="string">'users/show'</span>, {
        user : user
      })
    });
};
</code></pre><p>这段是创建用户的代码，根据post参数，保存入库，跳转到展示详情页面</p>
<pre><code>exports.update = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id =&gt; update, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params) + <span class="string">', body: '</span> + <span class="built_in">JSON</span>.stringify(req.body));

    <span class="keyword">var</span> id = req.params.id; 

    User.updateById(id,{name: req.body.name,password: req.body.password}, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>{
      <span class="built_in">console</span>.log(user);

      res.json({
        data:{
          redirect : <span class="string">'/users/'</span> + id
        },
        status:{
          code : <span class="number">0</span>,
          msg  : <span class="string">'delete success!'</span>
        }
      });
    });
};
</code></pre><p>和创建类似，它是根据id来更新内容</p>
<pre><code>exports.destroy = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
  <span class="built_in">console</span>.log(req.method + <span class="string">' /users/:id =&gt; destroy, query: '</span> + <span class="built_in">JSON</span>.stringify(req.query) + 
    <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(req.params) + <span class="string">', body: '</span> + <span class="built_in">JSON</span>.stringify(req.body));

  <span class="keyword">var</span> id = req.params.id;
  User.deleteById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(err);
    res.json({
      data:{},
      status:{
        code : <span class="number">0</span>,
        msg  : <span class="string">'delete success!'</span>
      }
    });
  });
};
</code></pre><p>和创建类似，它是根据id来删除内容</p>
<p>以上代码形式都是一样的</p>
<pre><code>exports.xxxx = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span> </span>{
  ...
}
</code></pre><p>他实际上connect中间件的标准写法，如果你熟悉express，可以非常简单的上手，看了这些代码，你一定很好奇，User模型是怎么工作的，而且mongoose里并没有这些方法啊，下面会详细说明</p>
<h2 id="模型层">模型层</h2><p>我们的模型层使用的是比较传统的mongoose，如果需要promise库，可以搭配bluebird</p>
<pre><code><span class="comment">/**
 * Created by alfred on 01/06/14.
 */</span>

<span class="keyword">var</span> mongoose    = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);
<span class="keyword">var</span> Schema      = mongoose.Schema;
<span class="keyword">var</span> MongooseDao = <span class="built_in">require</span>(<span class="string">'mongoosedao'</span>);

<span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(
    {<span class="string">"name"</span>:<span class="string">"String"</span>,<span class="string">"password"</span>:<span class="string">"String"</span>}
);

<span class="keyword">var</span> User = mongoose.model(<span class="string">'User'</span>, userSchema);
<span class="keyword">var</span> UserDao = <span class="keyword">new</span> MongooseDao(User);

<span class="built_in">module</span>.exports = UserDao;
</code></pre><p>这实际是最简单的定义mongoose模型的方法，我们唯一做的改进是增加了MongooseDao</p>
<p>DAO是java的概念，是data access object，即数据访问对象，就是传说的crud方法</p>
<p>你只要知道模型就好，为啥每个crud都要写呢？那得多烦啊</p>
<pre><code><span class="keyword">var</span> UserDao = <span class="keyword">new</span> MongooseDao(User);
</code></pre><p>这样就可以给user增加了基本的crud方法</p>
<p>所以在controller里我们看到了如下代码</p>
<ul>
<li>User.getAll(function(err, users){</li>
<li>User.getById(id, function(err, user) {</li>
<li>User.create({name: req.body.name,password: req.body.password}, function (err, user) {</li>
<li>User.updateById(id,{name: req.body.name,password: req.body.password}, function (err, user) {</li>
<li>User.deleteById(id, function (err) {</li>
</ul>
<p>这5个方法，完美的完成crud的所有操作，是不是很爽？至少少写了很多代码</p>
<p>而且当你想扩展的时候，你可以使用<code>User.model</code>来操作mongoose对象</p>
<p>比如login，我需要在User模型增加is_exist方法</p>
<pre><code><span class="keyword">var</span> mongoose    = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);
<span class="keyword">var</span> Schema      = mongoose.Schema;
<span class="keyword">var</span> MongooseDao = <span class="built_in">require</span>(<span class="string">'mongoosedao'</span>);

<span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(
    {<span class="string">"name"</span>:<span class="string">"String"</span>,<span class="string">"password"</span>:<span class="string">"String"</span>}
);

userSchema.methods.is_exist = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>{
  <span class="keyword">var</span> query;
  query = {
    username: <span class="keyword">this</span>.username,
    password: <span class="keyword">this</span>.password
  };
  <span class="keyword">return</span> <span class="keyword">this</span>.model(<span class="string">'User'</span>).findOne(query, cb);
};

<span class="keyword">var</span> User = mongoose.model(<span class="string">'User'</span>, userSchema);
<span class="keyword">var</span> UserDao = <span class="keyword">new</span> MongooseDao(User);

<span class="built_in">module</span>.exports = UserDao;
</code></pre><p>这就是mongoose里的实例方法，static方法也是一样，你可以玩各种花样</p>
<p>然后控制层</p>
<pre><code>exports.login = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span> </span>{
  username = req.body.username;
  password = req.body.password;

  user = <span class="keyword">new</span> User.model({
    username: username,
    password: password
  });

  <span class="keyword">return</span> user.is_exist(<span class="function"><span class="keyword">function</span><span class="params">(err, usr)</span> </span>{
     。。。
  });
}
</code></pre><p>是不是很简单？</p>
<h2 id="视图层">视图层</h2><p>视图层我们采用express默认的jade，无论各位怎么看，jade都可圈可点</p>
<p>1）extends 方式使用布局<br>2）include 复用模型代码<br>3）block 复用块代码</p>
<p>以new.jade和edit.jade为例，它们具有代表性</p>
<p>new.jade</p>
<pre><code>extends ../layouts/layout

block <span class="attribute">content</span>
  <span class="tag">h1</span> New user

  include user

  <span class="function"><span class="title">a</span><span class="params">(href=<span class="string">'/users'</span>)</span></span> Back
</code></pre><p>edit.jade</p>
<pre><code><span class="keyword">extends</span> ..<span class="regexp">/layouts/</span>layout

block content
  h1 Editing user

  <span class="keyword">include</span> user

  a(href=<span class="string">'/users/#{ user._id}'</span>) Show
  span |
  a(href=<span class="string">'/users'</span>) Back
</code></pre><p>首先要说明的是include用法，include类似于partial概念，可以包含一个jade作为一部分</p>
<p>jade里有一个约定，你include了谁，它就要把这个对象传进去</p>
<p>所以user.jade里才是我们复用的重点</p>
<pre><code>-<span class="ruby"> var _action = user._action == <span class="string">'edit'</span> ? <span class="string">'#'</span> <span class="symbol">:</span> <span class="string">'/users/'</span>
</span>-<span class="ruby"> var _method = user._action == <span class="string">'edit'</span> ? <span class="string">""</span>  <span class="symbol">:</span> <span class="string">"post"</span>
</span>-<span class="ruby"> var _type   = user._action == <span class="string">'edit'</span> ? <span class="string">"button"</span>  <span class="symbol">:</span> <span class="string">"submit"</span>
</span>-<span class="ruby"> var onClick  = user._action == <span class="string">'edit'</span> ?  <span class="string">"click_edit('user-"</span> + user._action + <span class="string">"-form','/users/"</span> + user._id + <span class="string">"/')"</span> <span class="symbol">:</span> <span class="string">""</span>
</span>form(id='user-#{<span class="ruby"> user._action}</span>-form',action="#{<span class="ruby">_action}</span>", method="#{<span class="ruby">_method}</span>",role='form')
  each n in ['user.name','user.password']
    -<span class="ruby"> m = eval(n);
</span>    div(class="field")
      label #{<span class="ruby">n.split(<span class="string">'.'</span>)[<span class="number">1</span>]}</span> #{<span class="ruby">m}</span>
      br
      input(type='text',name="#{<span class="ruby">n.split(<span class="string">'.'</span>)[<span class="number">1</span>]}</span>" ,value="#{<span class="ruby"> m == undefined ? <span class="string">''</span> <span class="symbol">:</span> m }</span>")

  div(class="actions") 
    input(type='#{<span class="ruby">_type}</span>',value='Submit',onClick='#{<span class="ruby">onClick}</span>')
</code></pre><p>这段是为了复用写的代码，可读性不强，但可以说明include用法，对于代码而言，达到了一定的复用</p>
<p>实际上我们自己jade的适合要尽可能的拆分成小块去复用，当需求变得时候更容易应变。提醒强迫症患者，当心物极必反，不要刻意去强求</p>
<h2 id="总结一下">总结一下</h2><p>RESTful架构大势所趋，代码写的标准了让人觉得赞</p>
<p>Expressjs下可以写的很规范，可以有做大应用，可以有很好的分层</p>
<p>展示了MVC + Routes的标准rest写法</p>
<p>使用了几个开源代码</p>
<ul>
<li>mount-routes</li>
<li>MongooseDao</li>
</ul>
<p>完成了以上工作，我们还要继续反思一下，既然rest是标准，写法很固定，是不是可以量产呢？答案是可以的，我展示的所有代码是根据一条命令搞定的</p>
<pre><code>moag user <span class="property">name</span>:<span class="type">string</span> password:<span class="type">string</span>
</code></pre><p>这就是我目前在写的一个开源项目，待可用的时候会公开的，敬请期待</p>
<p>延伸阅读</p>
<ul>
<li>Nodejs RESTFul架构实践之api篇 <a href="http://nodeonly.com/2015/06/14/node-restful-api.html" target="_blank" rel="external">http://nodeonly.com/2015/06/14/node-restful-api.html</a></li>
</ul>
<p>欢迎关注我的公众号【node全栈】</p>
<p><img src="/img/node全栈-公众号.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/09/expressjs-rest/" data-id="cid190g43000jam7fkp8pp32v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/jekyll-update/">jekyll update</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-update/">node update</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/08/07/mongoose-cli/">mongoose-cli</a>
          </li>
        
          <li>
            <a href="/2015/07/12/to-us/">良苦用心几人懂</a>
          </li>
        
          <li>
            <a href="/2015/07/07/gulp-in-action/">gulp结构化</a>
          </li>
        
          <li>
            <a href="/2015/07/07/npm-postinstall/">从npm tips到express插件机制设计</a>
          </li>
        
          <li>
            <a href="/2015/07/04/mongo-paging/">mongodb分页优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>